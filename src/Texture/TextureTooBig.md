# 问题描述

## 现象

纹理像素分辨率过大，比被贴图的表面更精细，也会出现问题。例如：

<img src="../assets/problem2.jpg" width = 600 />   

> &#x1F446; 左：期待效果 右：实际效果

## 原因

由于透视的原因，不同距离的屏幕像素对应的纹理像素区域不同

![](../assets/footprint.jpg)  
> **&#x1F446;** 有的像素对应一小部分纹理像素，有的像素对应较大区域的纹理像素

- 在近处，物体表面比纹理图更精细，即Texture Magnification问题，见上一页，表现为锯齿。  

> &#x1F50E;[Texture Magnification](TextureMagnification.md)

- 在远处，纹理图比物体表面精细，一个屏幕像素对应一片纹理像素，但只取一个纹理像素来代表这一片点，也会出现问题，表现为摩尔纹

# 解决方法一：超采样 MSAA

> &#x1F50E;[MSAA]()

可解决，但costly。

# 解决方法二： Mip map[44:20]


原理：点查询（采样）-->范围查询（取一个范围的平均）。

特点：快，不精确（近似），方形区域

## 具体步骤

1. 根据原始纹理，预处理出低分辨率的纹理，仅消耗额外1/3存储。
   
   [47:17]
   
   ![](../assets/mip.jpg)

2. 找出屏幕上的一个像素对应的纹理上的近似方形区域。
   
   [52:30]
   
   ![](../assets/mipmap3.jpg)

3. 根据mipmap计算边长为L的纹理方形区域的均值。边长为L的方形区域，会在第\\(\log _2L\\)层变成一个像素。直接查在\\(\log _2L\\)层纹理上查(u,v)的值即可。

## 效果
   
   [56：20]
   
   ![](../assets/mipmapresult.jpg)

   不同颜色代表查询不同的层，但是，存在两层之间的边界，边界处可能存在突变

# 改进：三线性插值

这是一种基于mip map的改进，把层数变成一个连续的值，能够解决层数边界上的突变

方法：根据层数再做一次插值，例如需要计算第1.8层的值，就把第1层的插值结果与第2层的插值结果再做一次插值 [57:52]

## 效果
   
   [1：00：20]
   
   ![](../assets/mipmapresult2.jpg)
   
   MipMap解决“问题描述”中问题的效果：
   
   ![](../assets/mipmapresult3.jpg)

   远处没有摩尔纹，但是变成了一片灰色，这是因为mipmap只能计算方形区域。而根据上图可以看出，屏幕的方形区域不对应纹理图上的方形区域。

# 改进：各项异性过滤(Anisotropic littering)
   
   对原始纹理做不均匀压缩，这样，方形压缩区域对应原始的矩形区域。[103：35]
   
   ![](../assets/anisotropic.jpg)
   
   屏幕的方形区域实际上是对应纹理空间的不规律形状，如果用正方形来代表这长条，会发生过渡blur。 [1：04：40]
   
   各项异性过滤能解决水平或竖直长方形的问题，不能解决倾斜长方形的问题。

# 改进：EWA Filtering
   [1:06:31] 
   
   ![](../assets/EWA.jpg)



------------------------------

> 本文出自CaterpillarStudyGroup，转载请注明出处。  
> https://caterpillarstudygroup.github.io/GAMES101_mdbook/