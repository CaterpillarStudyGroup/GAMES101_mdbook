<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>GAMES101</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The note of GAMES101">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/pagetoc.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><div>GAMES101</div></li><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction 介绍</a></li><li class="chapter-item expanded "><a href="Pipeline.html"><strong aria-hidden="true">2.</strong> 实时渲染管线</a></li><li class="chapter-item expanded "><a href="MVP/MVP.html"><strong aria-hidden="true">3.</strong> MVP 模型，视图，投影</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="MVP/View.html"><strong aria-hidden="true">3.1.</strong> View 视图</a></li><li class="chapter-item expanded "><a href="MVP/Projection.html"><strong aria-hidden="true">3.2.</strong> Projection 投影</a></li><li class="chapter-item expanded "><a href="MVP/OrthographicProjection.html"><strong aria-hidden="true">3.3.</strong> 正交投影</a></li><li class="chapter-item expanded "><a href="MVP/PerspectiveProjection.html"><strong aria-hidden="true">3.4.</strong> 透视投影</a></li><li class="chapter-item expanded "><a href="MVP/Fov2Frustum.html"><strong aria-hidden="true">3.5.</strong> 根据Fov定义cubic、Frustum</a></li></ol></li><li class="chapter-item expanded "><a href="Rasterization/Rasterization.html"><strong aria-hidden="true">4.</strong> Rasterization 光栅化</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Rasterization/Antialiasing.html"><strong aria-hidden="true">4.1.</strong> Antialiasing 反走样</a></li><li class="chapter-item expanded "><a href="Rasterization/AntialiasingInFrequency.html"><strong aria-hidden="true">4.2.</strong> 从频域的角度分析走样</a></li><li class="chapter-item expanded "><a href="Rasterization/TimeVsFrequency.html"><strong aria-hidden="true">4.3.</strong> 时域 VS. 频域</a></li><li class="chapter-item expanded "><a href="Rasterization/AntialiasingMore.html"><strong aria-hidden="true">4.4.</strong> 反走样算法</a></li><li class="chapter-item expanded "><a href="Rasterization/Others.html"><strong aria-hidden="true">4.5.</strong> Others</a></li></ol></li><li class="chapter-item expanded "><a href="Occlusion.html"><strong aria-hidden="true">5.</strong> 可见性/遮挡</a></li><li class="chapter-item expanded "><a href="Texture/Texture.html"><strong aria-hidden="true">6.</strong> Texture Mapping 纹理映射</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Texture/BarycentricCoordinates.html"><strong aria-hidden="true">6.1.</strong> 重心坐标插值</a></li><li class="chapter-item expanded "><a href="Texture/TextureMapping.html"><strong aria-hidden="true">6.2.</strong> 纹理映射</a></li><li class="chapter-item expanded "><a href="Texture/TextureMagnification.html"><strong aria-hidden="true">6.3.</strong> 纹理放大</a></li><li class="chapter-item expanded "><a href="Texture/TextureTooBig.html"><strong aria-hidden="true">6.4.</strong> 纹理像素分辨率过大</a></li></ol></li><li class="chapter-item expanded "><a href="Shadow/Shadow.html"><strong aria-hidden="true">7.</strong> 阴影</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Shadow/ShadowMapping.html"><strong aria-hidden="true">7.1.</strong> Shadow Mapping算法</a></li><li class="chapter-item expanded "><a href="Shadow/CascadeShadow.html"><strong aria-hidden="true">7.2.</strong> Cascade Shadow</a></li></ol></li><li class="chapter-item expanded "><a href="Shading/Shading.html"><strong aria-hidden="true">8.</strong> Shading 着色</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="RayTracing/BasicRadiometry.html"><strong aria-hidden="true">8.1.</strong> 辐射度量学</a></li><li class="chapter-item expanded "><a href="RayTracing/BRDF.html"><strong aria-hidden="true">8.2.</strong> BRDF - 双向反射分布函数</a></li><li class="chapter-item expanded "><a href="RayTracing/RenderEquation.html"><strong aria-hidden="true">8.3.</strong> 渲染方程</a></li><li class="chapter-item expanded "><a href="Shading/Style.html"><strong aria-hidden="true">8.4.</strong> 着色频率</a></li><li class="chapter-item expanded "><a href="Shading/Normal.html"><strong aria-hidden="true">8.5.</strong> 计算一个点/像素的法向量</a></li></ol></li><li class="chapter-item expanded "><a href="Light/Light.html"><strong aria-hidden="true">9.</strong> 光</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Light/SimpleLightSolution.html"><strong aria-hidden="true">9.1.</strong> 简单方案</a></li><li class="chapter-item expanded "><a href="Light/Pre-computedGlobalIllumination.html"><strong aria-hidden="true">9.2.</strong> 预计算GI</a></li><li class="chapter-item expanded "><a href="Light/SHLightmap.html"><strong aria-hidden="true">9.3.</strong> SH Lightmap</a></li><li class="chapter-item expanded "><a href="Light/LightProbe.html"><strong aria-hidden="true">9.4.</strong> Light Probe</a></li><li class="chapter-item expanded "><a href="Experience/EnvironmentMap.html"><strong aria-hidden="true">9.5.</strong> 环境贴图</a></li><li class="chapter-item expanded "><a href="Texture/Application.html"><strong aria-hidden="true">9.6.</strong> 2D纹理应用</a></li></ol></li><li class="chapter-item expanded "><a href="Material/Material.html"><strong aria-hidden="true">10.</strong> 材质和外观</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Shading/BlinnPhong.html"><strong aria-hidden="true">10.1.</strong> Blinn-Phong 材质模型</a></li><li class="chapter-item expanded "><a href="Material/Diffuse.html"><strong aria-hidden="true">10.2.</strong> 漫反射材质</a></li><li class="chapter-item expanded "><a href="Material/Glossy.html"><strong aria-hidden="true">10.3.</strong> Glossy材质</a></li><li class="chapter-item expanded "><a href="Material/Water.html"><strong aria-hidden="true">10.4.</strong> 玻璃和水</a></li><li class="chapter-item expanded "><a href="Material/Microfacet.html"><strong aria-hidden="true">10.5.</strong> 微表面材质</a></li><li class="chapter-item expanded "><a href="Material/IsotropicAnisotropic.html"><strong aria-hidden="true">10.6.</strong> 各项同性/各项异性材质</a></li></ol></li><li class="chapter-item expanded "><a href="RayTracing/RayTracing.html"><strong aria-hidden="true">11.</strong> 光线追踪</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="RayTracing/RayCasting.html"><strong aria-hidden="true">11.1.</strong> RayCasting</a></li><li class="chapter-item expanded "><a href="RayTracing/Whitted.html"><strong aria-hidden="true">11.2.</strong> Whitted-Style算法</a></li><li class="chapter-item expanded "><a href="RayTracing/RaySurfaceIntersection.html"><strong aria-hidden="true">11.3.</strong> 光线与隐式曲面的交点</a></li><li class="chapter-item expanded "><a href="RayTracing/RayTriangleIntersection.html"><strong aria-hidden="true">11.4.</strong> 光线与三角形的交点</a></li><li class="chapter-item expanded "><a href="RayTracing/RayMeshIntersection.html"><strong aria-hidden="true">11.5.</strong> 光线与Mesh的交点</a></li><li class="chapter-item expanded "><a href="RayTracing/MontoCarloIntegration.html"><strong aria-hidden="true">11.6.</strong> 蒙特卡罗积分</a></li><li class="chapter-item expanded "><a href="RayTracing/WhittedAgain.html"><strong aria-hidden="true">11.7.</strong> Whitted-Style Ray Tracing 的局限性</a></li><li class="chapter-item expanded "><a href="RayTracing/PathTracing.html"><strong aria-hidden="true">11.8.</strong> 路径追踪</a></li><li class="chapter-item expanded "><a href="RayTracing/PathTracingAdvance.html"><strong aria-hidden="true">11.9.</strong> 路径追踪进阶</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> 地形系统</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="TerrainRendering/HeightField.html"><strong aria-hidden="true">12.1.</strong> Height Field</a></li><li class="chapter-item expanded "><a href="TerrainRendering/NonHeightField.html"><strong aria-hidden="true">12.2.</strong> Non-Heightfield Terrain</a></li><li class="chapter-item expanded "><a href="TerrainRendering/PaintTerrainMaterials.html"><strong aria-hidden="true">12.3.</strong> Paint Terrain Materials</a></li></ol></li><li class="chapter-item expanded "><a href="Sky/SkyAtmosphere.html"><strong aria-hidden="true">13.</strong> Sky and Atmosphere</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Sky/Atmosphere.html"><strong aria-hidden="true">13.1.</strong> Atmosphere</a></li><li class="chapter-item expanded "><a href="Sky/MultiScattering.html"><strong aria-hidden="true">13.2.</strong> Multi Scattering</a></li><li class="chapter-item expanded "><a href="Sky/Cloud.html"><strong aria-hidden="true">13.3.</strong> Cloud</a></li><li class="chapter-item expanded "><a href="Sky/Fog.html"><strong aria-hidden="true">13.4.</strong> Fog</a></li></ol></li><li class="chapter-item expanded "><a href="AmbientOcclusion/AmbientOcclusion.html"><strong aria-hidden="true">14.</strong> Ambient Occlusion</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> Advanced Topics in Rendering</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="AdvancedRendering/AdvancedRayTracing.html"><strong aria-hidden="true">15.1.</strong> 高级光线传播</a></li><li class="chapter-item expanded "><a href="AdvancedRendering/AdcancedAppearcing.html"><strong aria-hidden="true">15.2.</strong> 高级Appreance建模</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.</strong> 纹理生成</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Texture/3DApplication.html"><strong aria-hidden="true">16.1.</strong> 3D纹理应用</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">17.</strong> 颜色</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Color/Camera.html"><strong aria-hidden="true">17.1.</strong> 相机</a></li><li class="chapter-item expanded "><a href="Color/LightField.html"><strong aria-hidden="true">17.2.</strong> 光场</a></li><li class="chapter-item expanded "><a href="Color/Color.html"><strong aria-hidden="true">17.3.</strong> 颜色</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">18.</strong> 动画</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Animation/MassSpringSystem.html"><strong aria-hidden="true">18.1.</strong> 质量弹簧系统</a></li><li class="chapter-item expanded "><a href="Animation/ParticleSystem.html"><strong aria-hidden="true">18.2.</strong> 粒子系统</a></li><li class="chapter-item expanded "><a href="Animation/RigidSimulation.html"><strong aria-hidden="true">18.3.</strong> 刚体模拟</a></li><li class="chapter-item expanded "><a href="Animation/FluidSimulation.html"><strong aria-hidden="true">18.4.</strong> 流体模拟</a></li><li class="chapter-item expanded "><a href="Animation/EulerVsLagrangian.html"><strong aria-hidden="true">18.5.</strong> 欧拉 Vs Lagrangion</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">GAMES101</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/CaterpillarStudyGroup/GAMES101_mdbook" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main><div class="sidetoc"><nav class="pagetoc"></nav></div>
                        <div style="break-before: page; page-break-before: always;"></div><h1 id="readme"><a class="header" href="#readme">README</a></h1>
<p>这个笔记以GAMES101为原型，保留了其中渲染相关的内容，并做了重新排版与补充。
数学、动画、仿真、几何等内容移至其它仓库。</p>
<p>但为了不影响到连接失效，沿用原来的仓库名字。</p>
<p>如有侵权，请联系删除</p>
<h1 id="课程主要内容"><a class="header" href="#课程主要内容">课程主要内容</a></h1>
<ul>
<li>实时渲染pipeline</li>
<li>投影功能与可见区域裁剪
<ul>
<li>MVP</li>
</ul>
</li>
<li>光栅化
<ul>
<li>反走样</li>
</ul>
</li>
<li>着色
<ul>
<li>渲染方程</li>
</ul>
</li>
<li>简化模型/经验模型
<ul>
<li>Bling Phong</li>
<li>环境贴图</li>
<li>GI</li>
</ul>
</li>
<li>光线追踪 Ray Tracing </li>
<li>其它
<ul>
<li>大地系统</li>
<li>天空系统</li>
</ul>
</li>
<li>渲染</li>
<li>显示</li>
</ul>
<h1 id="reference"><a class="header" href="#reference">Reference</a></h1>
<ol>
<li><a href="https://www.bilibili.com/video/BV1X7411F744?spm_id_from=333.337.search-card.all.click">GAMES101</a></li>
<li><a href="https://caterpillarstudygroup.github.io/GAMES104_mdbook/index.html">GAMES104</a></li>
<li><a href="https://caterpillarstudygroup.github.io/mathematics_basic_for_ML/index.html">数学基础</a></li>
</ol>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="real-time-rendering-pipeline"><a class="header" href="#real-time-rendering-pipeline">Real-time Rendering Pipeline</a></h1>
<p>实时渲染管线</p>
<blockquote>
<p><strong>📌</strong> 一个场景，最后到一张图，中间经历了什么过程，这个过程就是管线（pipeline），即一系列不同的操作。</p>
</blockquote>
<p>[35：24]<img src="./assets/37.PNG" alt="" /></p>
<h2 id="vertex-processing"><a class="header" href="#vertex-processing">Vertex Processing</a></h2>
<h3 id="mvp"><a class="header" href="#mvp">MVP</a></h3>
<p><img src="./assets/35.PNG" alt="" /></p>
<blockquote>
<p>👆 MVP是图中前三步。最后一步不是。</p>
</blockquote>
<p>MVP发生在图中的Vertex Processing。</p>
<blockquote>
<p>❓ 问：MVP的目标是把3D三角形投影到平面上。为什么这里只有点？<br />
答：因为MVP这一步不改变点的连接关系。所以不需要对边做投影。投影之后提取原来的边的关系就可以。</p>
</blockquote>
<h3 id="基于顶点的着色"><a class="header" href="#基于顶点的着色">基于顶点的着色</a></h3>
<p>基于顶点的着色发生在Vertex Processing。</p>
<h2 id="raserization"><a class="header" href="#raserization">Raserization</a></h2>
<ul>
<li>Sampling Triangle Coverage</li>
</ul>
<img src="assets/三角形.jpg" title="" alt="" width="239">
<p>对像素采样判断是否在三角形内，这一步发生在Raserization。</p>
<h2 id="fragment-processing"><a class="header" href="#fragment-processing">Fragment Processing</a></h2>
<h3 id="用z-buff判定可见性"><a class="header" href="#用z-buff判定可见性">用z-buff判定可见性</a></h3>
<p><img src="./assets/zbuffer.jpg" alt="" /></p>
<p>这一步发生在Fragment Processing</p>
<h3 id="纹理映射"><a class="header" href="#纹理映射">纹理映射</a></h3>
<h3 id="基于像素的shading"><a class="header" href="#基于像素的shading">基于像素的Shading</a></h3>
<p><img src="./assets/blinn-phong.jpg" alt="" /></p>
<p>基于像素的着色发生在Fragment Processing。</p>
<h1 id="shader-programs"><a class="header" href="#shader-programs">Shader Programs</a></h1>
<p>基于OpenGL的着色编程是工程问题，跳过</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mvp-1"><a class="header" href="#mvp-1">MVP：</a></h1>
<ol>
<li>
<p>model变换 --&gt; M</p>
<blockquote>
<p>确定object的position和rotation</p>
</blockquote>
</li>
<li>
<p>view变换 --&gt; V</p>
<blockquote>
<p>确定camera的position和rotation</p>
</blockquote>
</li>
<li>
<p>projection变换 --&gt; P</p>
<blockquote>
<p>建立object到camera的映射，使物体处于坐标中心的\([-1, 1]^3\)这个立方体中。</p>
</blockquote>
</li>
</ol>
<p>本节主要描述：对物体的观测，最终会让物体处于坐标中心的\([-1, 1]^3\)这个立方体中。</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="view-transformation"><a class="header" href="#view-transformation">View Transformation</a></h1>
<p>假设此时：</p>
<ul>
<li>已经做完model transformation，即物体已经摆好。</li>
<li>相机的位置已先好，即相机和物体的相对关系是确定的。</li>
</ul>
<p>现在要做的是：</p>
<ul>
<li>通过旋转、平移缩放等操作的组合，调整相机使其处于指定状态，为了便于后面的计算。</li>
<li>同时调整物体，保持相机和物体的相对关系不变。</li>
</ul>
<h2 id="定义camera的view"><a class="header" href="#定义camera的view">定义camera的view</a></h2>
<table><thead><tr><th></th><th>说明</th><th>camera当前的view</th><th>期望的view</th></tr></thead><tbody>
<tr><td>position</td><td>摄像机位置</td><td>\(\vec{e}\)</td><td>原点</td></tr>
<tr><td>gaze direction</td><td>摄像机朝向</td><td>\(\hat{g}\)</td><td>-Z轴(0,0,-1)</td></tr>
<tr><td>up direction</td><td>摄像机向上的方向</td><td>\(\hat{t}\)</td><td>Y轴(0,1,0)</td></tr>
</tbody></table>
<p><img src="MVP/../assets/tge.PNG" alt="" /> </p>
<p>我们期望一个摄像机（view）能够有如上参数，这样方便计算，但是真实的camera view不会和我们期望的相同，所以我们需要对camera的上述三个向量做转换，使得camera的view参数达到预期。</p>
<h2 id="view的变换"><a class="header" href="#view的变换">view的变换</a></h2>
<p>目的：通过旋转、平移缩放等操作的组合，调整相机使其处于指定状态。</p>
<ul>
<li>平移：e平移到origin</li>
<li>旋转：g-&gt;-Z, t-&gt;Y, g\(\times\)t-&gt;X</li>
<li>缩放：此处不涉及缩放</li>
</ul>
<h3 id="平移"><a class="header" href="#平移">平移</a></h3>
<p>平移 \(\vec{e}\) 到原点：</p>
<p>需要计算：原点 = \(T_{view} \cdot \vec{e}\)</p>
<p>用齐次坐标表达：</p>
<p>\[
\left[ \begin{array}{c}
0\\
0\\
0\\
1\\
\end{array} \right] =\left[ \begin{matrix}
1&amp;		0&amp;		0&amp;		?\\
0&amp;		1&amp;		0&amp;		?\\
0&amp;		0&amp;		1&amp;		?\\
0&amp;		0&amp;		0&amp;		1\\
\end{matrix} \right] \left[ \begin{array}{c}
x_e\\
y_e\\
z_e\\
1\\
\end{array} \right] 
\]</p>
<p>解得：</p>
<p>\[
T_{view}=\left[ \begin{matrix}
1&amp;        0&amp;        0&amp;        -x_e\\
0&amp;        1&amp;        0&amp;        -y_e\\
0&amp;        0&amp;        1&amp;        -z_e\\
0&amp;        0&amp;        0&amp;        1\\
\end{matrix} \right] 
\]</p>
<h3 id="旋转"><a class="header" href="#旋转">旋转</a></h3>
<p>将 \(\hat{g}\) 和 \(\hat{t}\) 旋转到-Z轴和Y轴，直接求出旋转矩阵 \(R\) 并不容易，但是由-Z轴和Y轴旋转到 \(\hat{g}\) 和 \(\hat{t}\) 就比较简单了，当我们得到 \(R^{-1}\) 后，进行逆运算，就能得到 \(R\)了，\(R=(R^{-1})^{T}\)。</p>
<p>\[
R_{view}^{-1}=\left[ \begin{matrix}
x_{\hat{g}\times \hat{t}}&amp;        x_t&amp;        x_{-g}&amp;        0\\
y_{\hat{g}\times \hat{t}}&amp;        y_t&amp;        y_{-g}&amp;        0\\
z_{\hat{g}\times \hat{t}}&amp;        z_t&amp;        z_{-g}&amp;        0\\
0&amp;        0&amp;        0&amp;        1\\
\end{matrix} \right] 
\]</p>
<p>\[
R_{view}^{}=\left[ \begin{matrix}
x_{\hat{g}\times \hat{t}}&amp;        y_{\hat{g}\times \hat{t}}&amp;        z_{\hat{g}\times \hat{t}}&amp;        0\\
x_t&amp;        y_t&amp;        y_{-g}&amp;        0\\
x_{-g}&amp;        y_{-g}&amp;        z_{-g}&amp;        0\\
0&amp;        0&amp;        0&amp;        1\\
\end{matrix} \right] 
\]</p>
<h3 id="旋转--平移"><a class="header" href="#旋转--平移">旋转 + 平移</a></h3>
<p>通过对camera进行旋转和平移，使camera满足指定view旋转与平移结合的方式有两种：</p>
<ol>
<li>先旋转后平移</li>
<li>先平移后旋转</li>
</ol>
<p>根据常识可知，应该先平移再旋转。</p>
<p>因此有变换矩阵：</p>
<p>\[
M_{view} = R_{view} \cdot T_{view}
\]</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="projection-投影变换"><a class="header" href="#projection-投影变换">Projection 投影变换</a></h1>
<p>目的：使物体处于坐标中心的\([-1, 1]^3\)这个立方体中。</p>
<p>投影通常是指3D-&gt;2D的映射，但在这里，投影后的结果仍需要保留投影前的深度信息，用于渲染这一步计算遮挡情况。因此是3D-&gt;3D的。</p>
<h2 id="正交投影vs透视投影"><a class="header" href="#正交投影vs透视投影">正交投影vs透视投影</a></h2>
<ul>
<li>
<p>视觉效果上的区别</p>
<p>正交投影:（左），用于工程制图</p>
<p>透视投影：（右），呈现出近大远小的效果，类似于人眼</p>
<p><img src="MVP/../assets/%E4%B8%A4%E7%A7%8D%E6%8A%95%E5%BD%B1.jpg" alt="" /></p>
</li>
<li>
<p>数学上的区别:</p>
<p>正交投影: 认为相机位于无限远处认为相</p>
<p>透视投影: 机是近处的一个点</p>
</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="正交投影"><a class="header" href="#正交投影">正交投影</a></h1>
<p><img src="MVP/../assets/orthographic.jpg" alt="" /></p>
<h2 id="准备工作"><a class="header" href="#准备工作">准备工作</a></h2>
<p>把相机 view 变换为期望 view（转换到原点），方法是让相机参数乘以一个矩阵。</p>
<p>为了保持camera和object的相对位置不变，object也要同样乘以这样一个矩阵。</p>
<p>这样调整之后，object位于z轴负方向上的某个位置。</p>
<p><a href="MVP/View.html">参见view</a></p>
<h2 id="正交投影的主要过程"><a class="header" href="#正交投影的主要过程">正交投影的主要过程</a></h2>
<p><img src="MVP/../assets/26.PNG" alt="" /></p>
<p>$$
M_{ortho} = M_{scale} \cdot M_{trans}
$$</p>
<blockquote>
<p>💡 PPT 介绍了正交投影的一种简单理解的方式，让人能够直观地理解正交投影的结果，却也引入的歧义。让人误以为正交投影就是这么简单的过程。以至于后面讲正交投影的完整过程时听众会觉得confuse，为什么会有两个不一样的正交投影流程？因此在本文是中去掉了第一种理解方式。</p>
</blockquote>
<h2 id="正交投影中的平移"><a class="header" href="#正交投影中的平移">正交投影中的平移</a></h2>
<p><img src="MVP/../assets/%E6%AD%A3%E4%BA%A4%E6%8A%95%E5%BD%B1%E5%B9%B3%E7%A7%BB.jpg" alt="" /></p>
<table><thead><tr><th></th><th>当前位置</th><th>期望位置</th></tr></thead><tbody>
<tr><td>左右</td><td>[l,r]</td><td>[-(r-l)/2, (r-l)/2]</td></tr>
<tr><td>上下</td><td>[b,t]</td><td>[-(t-b)/2, (t-b)/2]</td></tr>
<tr><td>远近</td><td>[f,n]</td><td>[-(n-f)/2, (n-f)/2]</td></tr>
</tbody></table>
<blockquote>
<p><strong>📌补充：</strong> 由于投影的设定，l在坐标值上，小于r；b小于t，f小于n（因为朝向-Z轴）</p>
</blockquote>
<p>正交投影的平移矩阵为：</p>
<p>\[
M_{trans}=\left[ \begin{matrix}
1&amp;        0&amp;        0&amp;        -\frac{r+l}{2}\\
0&amp;        1&amp;        0&amp;        -\frac{t+b}{2}\\
0&amp;        0&amp;        1&amp;        -\frac{n+f}{2}\\
0&amp;        0&amp;        0&amp;        1\\
\end{matrix} \right] 
\]</p>
<h2 id="正交投影中的缩放"><a class="header" href="#正交投影中的缩放">正交投影中的缩放</a></h2>
<p><img src="MVP/../assets/%E6%AD%A3%E4%BA%A4%E6%8A%95%E5%BD%B1%E7%BC%A9%E6%94%BE.jpg" alt="" /></p>
<p>与平移同理。</p>
<p>正交投影的缩放矩阵为：</p>
<p>\[
M_{scale}=\left[ \begin{matrix}
\frac{2}{r-l}&amp;        0&amp;        0&amp;        0\\
0&amp;        \frac{2}{t-b}&amp;        0&amp;        0\\
0&amp;        0&amp;        \frac{2}{n-f}&amp;        0\\
0&amp;        0&amp;        0&amp;        1\\
\end{matrix} \right]
\]</p>
<h2 id="正交投影中的旋转"><a class="header" href="#正交投影中的旋转">正交投影中的旋转</a></h2>
<p>正交投影过程不涉及object的旋转，因此旋转矩阵\(M_{rotation}\)是单位阵。</p>
<p>此处变换顺序为：先平移再缩放无旋转，因此</p>
<p>$$
M = M_{scale} \dot M_{trans}
$$</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="透视投影"><a class="header" href="#透视投影">透视投影</a></h1>
<p><img src="MVP/../assets/perspective.jpg" alt="" /></p>
<h2 id="透视投影的主要过程"><a class="header" href="#透视投影的主要过程">透视投影的主要过程</a></h2>
<p>透视投影的过程是先将Frustum（截锥体）转换为Cuboid（长方体），然后再用上面的方法对长方体做正交投影：</p>
<p><img src="MVP/../assets/%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1%E8%BF%87%E7%A8%8B.jpg" alt="" /></p>
<blockquote>
<p>💡 我的理解</p>
<ol>
<li>在Frustum（截锥体）-&gt; Cuboid（长方体）之前应该有一步平移的过程，让Frustum的中心轴与z轴重合。类似于正交投影中的第一步。因此真正的过程应该是这样的：<br />
平移（正交投影的第一步） ===&gt; Frustum（截锥体）-&gt; Cuboid（长方体） ===&gt; 缩放（正交投影的第二步）</li>
<li>课程中用挤压来解决“Frustum（截锥体）-&gt; Cuboid（长方体）”的过程，方便理解的同时却也引入的歧义。因为这里的Frustum是视锥体，跟几何锥体还是有区别的。这也是为什么挤压之后z会变。</li>
</ol>
</blockquote>
<p>要把Frustum转换为Cubuid是仿射变换的过程，主要方法仍是求出仿射变换的矩阵。</p>
<p>在正交投影中，是根据正交变换的过程，将仿射变换矩阵分解为S, R, T三个部分，依次计算出S， R, T再将它们合并。</p>
<p>在透视投影中，仍然不涉及旋转，但是平移和缩放的过程是揉合在一起的，难以拆分，因此采用选取特殊点的方式，直接求出投视投影的变换矩阵。</p>
<h2 id="m_persprightarrow-ortho"><a class="header" href="#m_persprightarrow-ortho">\(M_{persp\rightarrow ortho}\)</a></h2>
<h3 id="侧面分析"><a class="header" href="#侧面分析">侧面分析</a></h3>
<p>从侧面看，存在相似三角形（图中很容易看出）</p>
<p><img src="MVP/../assets/%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B12.jpg" alt="" /></p>
<p>通过相似三角形，可以得到：</p>
<p>\[
y'=\frac{n}{z}y\\
x'=\frac{n}{z}x
\]</p>
<blockquote>
<p>💡 这个公式成立的前提是frustum的中心轴与z轴重合，这也印证了前面提到的“frustum-&gt;cuboid之前应该先平移”。</p>
</blockquote>
<p>我们的目的是将 \((x, y, z)\) 转换为 \((x', y', z)\)。</p>
<p>现在可以得到：</p>
<p>\[
\left( \begin{array}{c}
x\\
y\\
z\\
1\\
\end{array} \right) \Rightarrow \left( \begin{array}{c}
nx/z\\
ny/z\\
unknown\\
1\\
\end{array} \right) 
\]</p>
<p>为坐标乘以 \(z\)，得：</p>
<p>\[
\left( \begin{array}{c}
x\\
y\\
z\\
1\\
\end{array} \right) \Rightarrow \left( \begin{array}{c}
nx/z\\
ny/z\\
unknown\\
1\\
\end{array} \right) ==\left( \begin{array}{c}
nx\\
ny\\
still,,unknown\\
z\\
\end{array} \right) 
\]</p>
<p>想要将 \(\left( \begin{array}{c}
x\\
y\\
z\\
1\\
\end{array} \right)\) 投影为 \(\left( \begin{array}{c}
nx\\
ny\\
unknown\\
z\\
\end{array} \right) \)，需要求一个投影矩阵：</p>
<p>\[
M_{persp\rightarrow ortho}^{\left( 4\times 4 \right)}\left( \begin{array}{c}
x\\
y\\
z\\
1\\
\end{array} \right) =\left( \begin{array}{c}
nx\\
ny\\
unknown\\
z\\
\end{array} \right) 
\]</p>
<p>我们已经知道一些数据了，所以能求出M的一些值（显然，由上式可得）：</p>
<p>\[
M_{persp\rightarrow ortho}^{\left( 4\times 4 \right)}=\left( \begin{matrix}
n&amp;        0&amp;        0&amp;        0\\
0&amp;        n&amp;        0&amp;        0\\
?&amp;        ?&amp;        ?&amp;        ?\\
0&amp;        0&amp;        1&amp;        0\\
\end{matrix} \right) 
\]</p>
<h3 id="n面分析和f面分析"><a class="header" href="#n面分析和f面分析">n面分析和f面分析</a></h3>
<p>M已经被解决不少了，但还差一些，不过，我们还有一些坐标点不变的性质可以使用：</p>
<ul>
<li>
<p>Frustum的n（近处）面，所有坐标是不变化的。</p>
</li>
<li>
<p>f面的Z轴坐标值，是不变化的；</p>
</li>
<li>
<p>Z轴穿过的中心点的坐标值，是不变化的。</p>
</li>
</ul>
<p><img src="MVP/../assets/%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B11.jpg" alt="" /></p>
<p>n面，所有坐标点不变，那么取一个n面上随便一点，该点的Z轴坐标值为n，即：</p>
<p>\[
\left( \begin{array}{c}
x\\
y\\
n\\
1\\
\end{array} \right)
\]</p>
<p>为坐标乘以n：</p>
<p>\[
\left( \begin{array}{c}
nx\\
ny\\
n^2\\
n\\
\end{array} \right)
\]</p>
<p>既然这一点在投影前后不会变化，我们可以列出下面的式子：</p>
<p>\[
\left( \begin{array}{c}
nx\\
ny\\
n^2\\
n\\
\end{array} \right) =\left( \begin{matrix}
n&amp;        0&amp;        0&amp;        0\\
0&amp;        n&amp;        0&amp;        0\\
?&amp;        ?&amp;        ?&amp;        ?\\
0&amp;        0&amp;        1&amp;        0\\
\end{matrix} \right) \left( \begin{array}{c}
x\\
y\\
n\\
1\\
\end{array} \right) 
\]</p>
<p>上式其实只剩下下面这个式子要求：</p>
<p>\[
n^2=\left( ?,  ?,  ?,  ? \right) \left( \begin{array}{c}
x\\
y\\
n\\
1\\
\end{array} \right) 
\]</p>
<p>具体来说，是这样的：</p>
<p>\[
n^2=\left( 0,  0,  A,  B \right) \left( \begin{array}{c}
x\\
y\\
n\\
1\\
\end{array} \right) 
\]</p>
<p>于是可以得到：</p>
<p>\[
An+B=n^2
\]</p>
<p>同理，在f面上，变换后点(0,0,f)不变，可以得到：</p>
<p>\[
Af+B=f^2
\]</p>
<p>联立上述AB方程，解得：</p>
<p>\[
A=n+f\\
B=-nf
\]</p>
<p>所以我们推导出了透视投影的一个变换矩阵：</p>
<p>\[
M_{persp\rightarrow ortho}^{\left( 4\times 4 \right)}=\left( \begin{matrix}
n&amp;        0&amp;        0&amp;        0\\
0&amp;        n&amp;        0&amp;        0\\
0&amp;        0&amp;        n+f&amp;        -nf\\
0&amp;        0&amp;        1&amp;        0\\
\end{matrix} \right) 
\]</p>
<h2 id="透视投影矩阵"><a class="header" href="#透视投影矩阵">透视投影矩阵</a></h2>
<p>透视投影的最终的变换矩阵是 <strong>M = M（正交）M（透视）</strong></p>
<h1 id="为什么透视投影会z会后移"><a class="header" href="#为什么透视投影会z会后移">为什么透视投影会z会后移</a></h1>
<h2 id="从数学上"><a class="header" href="#从数学上">从数学上</a></h2>
<p>定义z'为变换后的z坐标，那么z' = (n+f)-nf/z</p>
<p>\[
f = z' - z 
= (n+f) - nf/z -z
\]</p>
<p>\[
zf = -z^2 + (n+f)z - nf
\]</p>
<p>zf是一个开口向下的二次曲线。它与x轴的交点在z=n处和z=f处。当z位于(f, n)区间时，zf&gt;0。</p>
<p>由于f&lt;0且n&lt;0，当z位于(f, n)区间时，z&lt;0，因此f&lt;0，即z'-z&lt;0</p>
<p>z'&lt;z，因此z会变远。</p>
<h2 id="从直觉上"><a class="header" href="#从直觉上">从直觉上</a></h2>
<p>一开始会觉得有点奇怪，违反直觉。细想之后觉得是很合理。<br />
因为透视投影要表现出近大远小的效果。近大不止是x轴和y轴的大，z轴上也会大。即同一个物体，如果放得近，它在z轴上会更大点。<br />
空间上也是如此，透视前的空间，把它以z=0分成前后均匀的两半，近的那一半，在透视后必然要占更大的z轴范围，因此z会往后。</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="根据fov定义cubicfrustum"><a class="header" href="#根据fov定义cubicfrustum">根据Fov定义cubic、Frustum</a></h1>
<blockquote>
<p><strong>📌补充：</strong> 定义一个视锥，只需要视角和宽高比即可，其他参数可以转换。</p>
</blockquote>
<ol>
<li>
<p>描述立方体的符号：l，r，u，d，f，n</p>
</li>
<li>
<p>描述屏幕的符号：</p>
</li>
</ol>
<img src="MVP/../assets/观察.jpg" title="" alt="" width="419">
<ul>
<li>宽高比（Aspect ratio）</li>
<li>width/height</li>
<li>视角（Field of view）</li>
</ul>
<img src="MVP/../assets/%E8%A7%86%E8%A7%92.jpg" title="" alt="" width="297">
<ol start="3">
<li>用符号描述屏幕和立方体的关系</li>
</ol>
<p>把视角和宽高比转换为l、r、b、t</p>
<p><img src="MVP/../assets/%E8%A7%86%E8%A7%92%E8%BD%AC%E6%8D%A2.jpg" alt="" /></p>
<p>由图可得以下关系：</p>
<p>\[
\tan \frac{fovY}{2}=\frac{t}{|n|}
\]</p>
<p>\[
aspect=\frac{r}{t}
\]</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>当观测结束后，所有物体到了[-1, 1]的三次方这个立方体中，那么，下一步是什么？将其放在屏幕上。</p>
<h1 id="什么是光栅化"><a class="header" href="#什么是光栅化">什么是光栅化</a></h1>
<blockquote>
<p>🔎<br />
pixel：像素，picture element，一个小方块，且方块内颜色不变<br />
Raster:屏幕，由像素组成二维数组<br />
Rasterize: 光栅化<br />
Triangle Mesh: 三角形面片</p>
</blockquote>
<p>光栅化，即把对象（object）画在屏幕（raster）上。对象是指cubic中的内容，常用三角形面片表示对象的表面。屏幕，由像素（pixel）组成的2D数组。数组的大小代码的屏幕的分辨率。<br />
具体过程可以描述为：找到对象表面在cubic中的位置，根据cubic与raster的关系，确定它在raster上应出现的位置。在raster的正确的位置上渲染对象。</p>
<p>将观测的物体在屏幕上显示，就是<strong>光栅化</strong>。</p>
<h1 id="定义屏幕空间"><a class="header" href="#定义屏幕空间">定义屏幕空间</a></h1>
<p>在屏幕上的坐标系</p>
<p><img src="Rasterization/../assets/%E5%B1%8F%E5%B9%95%E5%9D%90%E6%A0%87.jpg" alt="" /></p>
<ul>
<li>原点在左下角，向右为x正方向，向上为y正方向</li>
<li>每个像素的坐标是整数，范围为[0, width)  [0, height)</li>
<li>像素(x， y)的中心位置：(x+0.5, y+0.5)</li>
</ul>
<blockquote>
<p>❗注意区分<strong>坐标</strong>与<strong>位置</strong>的不同含义</p>
</blockquote>
<blockquote>
<p>📌课程中关于显示器的部分被我跳过了，因为我认为与算法相关度不大。</p>
</blockquote>
<h1 id="光栅化的最基本的流程"><a class="header" href="#光栅化的最基本的流程">光栅化的最基本的流程</a></h1>
<h2 id="step-1-选取cubic中物体的表面三角形"><a class="header" href="#step-1-选取cubic中物体的表面三角形">Step 1: 选取cubic中物体的表面三角形</a></h2>
<p>3D空间中的物体，通常使用三角形面片来描述物体的表面。所谓把物体画到屏幕上，实际上就是把这些三角形面片画到屏幕上。</p>
<p>为什么用三角形描述物体表面？</p>
<ol>
<li>
<p>三角形是最基本的多边形（其他多边形可以由三角形拼成）</p>
</li>
<li>
<p>一个三角形一定在一个平面上</p>
</li>
<li>
<p>三角形关于“内”、“外”的定义是明确的</p>
</li>
<li>
<p>给定三角形三个顶点的属性，其内部任意点的属性可以通过插值得出</p>
</li>
</ol>
<h2 id="step-2-根据三角形在cubic内的坐标计算出它在屏幕上的位置浮点数"><a class="header" href="#step-2-根据三角形在cubic内的坐标计算出它在屏幕上的位置浮点数">Step 2: 根据三角形在cubic内的坐标计算出它在屏幕上的位置（浮点数）</a></h2>
<p>坐标系的变换，只需要计算出正确的变换矩阵就可以实现。</p>
<p><img src="Rasterization/../assets/%E5%B1%8F%E5%B9%95%E6%98%A0%E5%B0%84.jpg" alt="" /></p>
<p>\[
\begin{bmatrix}
x' \\
y' \\
1 \\
1 \\
\end{bmatrix} = \begin{bmatrix}
S &amp; T \\
0 &amp; 1 \\
\end{bmatrix}\begin{bmatrix}
x \\
y \\
z \\
1
\end{bmatrix}
\]</p>
<p>其中S是指缩放，T是指平移，这里面不涉及到旋转。</p>
<p>对变换做以下假设：</p>
<ol>
<li>忽略Z轴</li>
<li>将xy平面：[-1,1]^2 转换到 [0, width] X [0, height]</li>
<li>不涉及旋转</li>
</ol>
<p>选取部分特殊点，代入计算，即可得出变换矩阵为：</p>
<p>\[
M_{viewport}=\left( \begin{matrix}
\frac{width}{2}&amp;        0&amp;        0&amp;        \frac{width}{2}\\
0&amp;        \frac{height}{2}&amp;        0&amp;        \frac{height}{2}\\
0&amp;        0&amp;        1&amp;        0\\
0&amp;        0&amp;        0&amp;        1\\
\end{matrix} \right) 
\]</p>
<h2 id="step-3-把三角形画在屏幕上"><a class="header" href="#step-3-把三角形画在屏幕上">Step 3: 把三角形画在屏幕上</a></h2>
<p>根据上面的转换公式，可以得出三角形上每个点对应在屏幕上的位置（浮点数）。但屏幕上像素的下标是整数。如下图：</p>
<p><img src="Rasterization/../assets/%E5%9D%90%E6%A0%87%E5%88%B0%E5%83%8F%E7%B4%A0.jpg" alt="" /></p>
<p>怎么确定每个像素格子是否需要被渲染成三角形的颜色？<br />
最简单的方法是：判断<strong>屏幕空间</strong>中每个像素的中心是否在三角形的内部。</p>
<img src="Rasterization/../assets/三角形.jpg" title="" alt="" width="239">
<h3 id="方法一采样方法"><a class="header" href="#方法一采样方法">方法一：采样方法</a></h3>
<pre><code>依次遍历每个像素(x, y)：
    取像素中心的位置(x+0.5, y+0.5)
    判断像素中心是否在三角形内部（叉乘）
    如果在内：
        渲染
    如果在外：
        渲染
    如果在三角形边上：
        自己决定是否渲染
</code></pre>
<blockquote>
<p>🔎<strong>判断三角形的内和外：</strong><br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/Dependency/Vector.html#%E5%9C%A8%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%</p>
</blockquote>
<p>缺点：必须要依次check每个pixel</p>
<h3 id="方法二bounding-box"><a class="header" href="#方法二bounding-box">方法二：Bounding Box</a></h3>
<p>对整个屏幕遍历，然后判断每个像素的中心是否在三角形内，这太傻了。</p>
<p>正确的做法是，只遍历包围三角形的最小矩阵，称之为三角形的包围盒。</p>
<img src="Rasterization/../assets/包围盒.jpg" title="" alt="" width="303">
<p>局限性：<br />
对于这种情况仍有较大的计算量。</p>
<p><img src="Rasterization/../assets/bbox.PNG" alt="" /></p>
<h3 id="方法三incremental"><a class="header" href="#方法三incremental">方法三：Incremental</a></h3>
<p>一种启发式的方法，比较容易想到，也懒得记了。</p>
<p><img src="Rasterization/../assets/27.PNG" alt="" /></p>
<h1 id="光栅化的结果"><a class="header" href="#光栅化的结果">光栅化的结果</a></h1>
<img src="Rasterization/../assets/走样.jpg" title="" alt="" width="425">
<p>当按照像素中心是否在三角形内的采样方式采样后，得到了不理想的结果。</p>
<p>产生了锯齿！（jaggies）</p>
<p>消除锯齿是图像学致力于解决的重要问题。</p>
<p>抗锯齿，也叫反走样。</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><img src="Rasterization/../assets/走样.jpg" title="" alt="" width="425">
<p>消除锯齿是图像学致力于解决的重要问题。</p>
<p>抗锯齿，也叫反走样。</p>
<h1 id="反走样antialiasing的定性分析与解决方法"><a class="header" href="#反走样antialiasing的定性分析与解决方法">反走样（Antialiasing）的定性分析与解决方法</a></h1>
<h2 id="采样理论"><a class="header" href="#采样理论">采样理论</a></h2>
<p>Photo是对image的采样<br />
video是在时间维度的采样<br />
它们都是将连续的信息离散化。</p>
<p>采样会产生 Artifact，例如：</p>
<p><img src="Rasterization/../assets/07-14.png" alt="" /></p>
<ul>
<li>锯齿</li>
<li>摩尔纹</li>
<li>车轮效应</li>
</ul>
<p>采样Artifact的本质原因：渲染的采样频率与真实世界的频率不一致。</p>
<h2 id="反走样方法"><a class="header" href="#反走样方法">反走样方法</a></h2>
<p>先对object模糊化，然后再采样</p>
<p>模糊化的过程使用滤波实现。</p>
<p>采样后，中心点红色，边界点粉红色</p>
<p><img src="Rasterization/../assets/%E6%A8%A1%E7%B3%8A%E9%87%87%E6%A0%B7.jpg" alt="" /></p>
<blockquote>
<p>✅ 先采样再模糊化不能起到反走样的效果</p>
</blockquote>
<h1 id="遗留问题"><a class="header" href="#遗留问题">遗留问题</a></h1>
<ol>
<li>为什么先采样再模糊化不能起到反走样的效果？</li>
<li>为什么采样速度跟不上信号变化的速度会产生走样？</li>
</ol>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>上节提到，走样的本质原因是信号的变化速度太快，采样的速度跟不上。</p>
<p>变化速度与采样速度，都是与频率相关的概念，因此本节从频域的角度来分析走样问题。</p>
<h1 id="频域的相关概念"><a class="header" href="#频域的相关概念">频域的相关概念</a></h1>
<h2 id="余弦波"><a class="header" href="#余弦波">余弦波</a></h2>
<p>\(\cos 2\pi fx\)，其中f代表频率。f越大，则信号变化越快。</p>
<div align="center"> <img src="Rasterization/../assets/余弦函数.jpg" width = 485 /> </div>
<h2 id="傅里叶级数展开"><a class="header" href="#傅里叶级数展开">傅里叶级数展开：</a></h2>
<p>任何一个周期函数可以写成：不同频率的正/余弦函数的线性组合，以及一个常数。</p>
<p><img src="Rasterization/../assets/%E5%82%85%E9%87%8C%E5%8F%B6%E5%B1%95%E5%BC%80.jpg" alt="" /></p>
<blockquote>
<p>❓ 非周期函数会怎么样呢？</p>
</blockquote>
<h2 id="傅里叶变换可逆"><a class="header" href="#傅里叶变换可逆">傅里叶变换（可逆）</a></h2>
<div align="center"> <img title="" src="Rasterization/../assets/傅里叶变换.jpg" width="589" /></div>
<p>傅里叶变换是指把函数转为它在频域上级数展开的形式。</p>
<h1 id="函数与采样的关系"><a class="header" href="#函数与采样的关系">函数与采样的关系</a></h1>
<h2 id="函数的频率"><a class="header" href="#函数的频率">函数的频率</a></h2>
<p>基于傅里叶变换，可以把函数分解为不同的频率的函数<br />
<img src="Rasterization/../assets/28.PNG" alt="" /><br />
频率高，即代表信号变化快。也就是说，一个函数是由各种不同频率的信号混合而成的。</p>
<h2 id="采样的频率"><a class="header" href="#采样的频率">采样的频率</a></h2>
<p>以相同采样频率对以上函数采样</p>
<p>通过采样点能恢复出低频信息，不能恢复出高频信息。</p>
<p>走样的本质原因的数学描述：两个不同频率（蓝黑）的信号，在某采样频率下，得到了完全相同的采样点，因此无法区分。</p>
<p><img src="Rasterization/../assets/%E9%87%87%E6%A0%B7%E4%B8%A4%E4%B8%AA%E5%87%BD%E6%95%B0.jpg" alt="" /></p>
<h1 id="图像中的频率成分"><a class="header" href="#图像中的频率成分">图像中的频率成分</a></h1>
<p>对图像信息做傅里叶变换，就可以把图像（时域信息）转成频域信息：</p>
<p><img src="Rasterization/../assets/低频高频.jpg" title="" alt="" width="337"><img src="Rasterization/../assets/频率图.jpg" title="" alt="" width="337"></p>
<p>图像的频域图具有以下特点：</p>
<ul>
<li>图中点越亮代表此处频率的能量越高</li>
<li>图像中的信息大部分为低频信息（自然生成的图像都有此特点）</li>
<li>由于强行把图像周期化，红色框中的亮线是图像跨越边界时产生的高频信息，这些高频信息可以忽略。</li>
</ul>
<h2 id="高通-filter"><a class="header" href="#高通-filter">高通 filter</a></h2>
<p><strong>滤波：即把某些信息（即特定的频率分量）去掉。</strong></p>
<p>保留频域图中的高频信息，再通过逆傅里叶变换把频域图恢复成原始图像。发现图像只剩下了原图的轮廓部分。</p>
<img title="" src="Rasterization/../assets/高通.jpg" alt="" width="476">
<p>解释：</p>
<p>保留的高频信息对应于图像边界。因为图像边缘为信号的剧变处。</p>
<h2 id="低通-filter"><a class="header" href="#低通-filter">低通 filter</a></h2>
<p>同理，只保留图像的低频信息，图像会变模糊，失去边界</p>
<img title="" src="Rasterization/../assets/低通.jpg" alt="" width="476">
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="滤波-vs-卷积-vs-平均"><a class="header" href="#滤波-vs-卷积-vs-平均">滤波 VS 卷积 VS 平均</a></h1>
<h2 id="卷积-vs-平均"><a class="header" href="#卷积-vs-平均">卷积 VS 平均</a></h2>
<p>结论1： <strong>卷积可以看作是个局部区域的加权平均， 卷积kernel即局部加权</strong></p>
<p><img src="Rasterization/../assets/29.PNG" alt="" /></p>
<h2 id="卷积-vs-滤波"><a class="header" href="#卷积-vs-滤波">卷积 VS 滤波</a></h2>
<blockquote>
<p>🔎 卷积定理：<br />
时域卷积 = 频域乘积<br />
时域乘积 = 频域卷积</p>
</blockquote>
<p>图像的卷积操作是从信号的卷积运算中借鉴过来的概念。虽然不完全相同，其本质是一样的。<br />
图像的卷积操作可以看作中对图像的时域信息做卷积运算，时域信息的卷积运算又可以转化为频域上的乘积运算。前面所讲的滤波操作实际上就是用频域上的乘积运算来实现的。因此图像的时域卷积操作与频域滤波操作本质上是一致的。</p>
<p>例子一：以低通滤波为例</p>
<img title="" src="Rasterization/../assets/时域卷积.jpg" alt="" width="507">  
<p>例子二：</p>
<p><img src="Rasterization/../assets/30.PNG" alt="" /><img src="Rasterization/../assets/31.PNG" alt="" /></p>
<blockquote>
<p>❓ 这个例子想说明什么？</p>
</blockquote>
<p>结论2：<strong>时域卷积 = 频域滤波， 卷积kernel = 频域filter</strong></p>
<h2 id="结论"><a class="header" href="#结论">结论</a></h2>
<p>时域卷积 = 频域滤波 = 局部加权平均</p>
<p>卷积kernel = 频域filter = 局部加权</p>
<h1 id="采样-vs-频域卷积"><a class="header" href="#采样-vs-频域卷积">采样 VS 频域卷积</a></h1>
<h2 id="例子"><a class="header" href="#例子">例子</a></h2>
<img title="" src="Rasterization/../assets/时域采样和频域采样.jpg" alt="" width="536">  
<p>解释：</p>
<p>a：时域信号</p>
<p>b：a对应的频域信号</p>
<p>c：对a进行采样的周期采样函数</p>
<p>d：采样函数的频域表示</p>
<p>e：对a进行采样的结果，即a与c乘积的结果</p>
<p>f：采样结果的频域表示。由于时域乘积=频域卷积，这也是b与d卷积的结果</p>
<h2 id="分析"><a class="header" href="#分析">分析</a></h2>
<p>采样是通过时域上的乘积操作实现的。</p>
<p>时域乘积 = 频域卷积</p>
<p>\[
f_1\left( x \right) \times f_2\left( x \right) \Longleftrightarrow F_1\left( \omega \right) \otimes F_2\left( \omega \right) 
\]</p>
<blockquote>
<p>💡 \(f_1\left( x \right)\) 是信号（a）， \(f_2\left( x \right)\)是采样信号（c）， \(F_1\left( \omega \right)\) 是a的频谱（b）  \(F_2\left( \omega \right)\) 是采样信号的频谱</p>
</blockquote>
<p>结论：<strong>采样就是把原信号的频谱以特定周期呈现。</strong></p>
<p>采样周期长 \(\Longrightarrow \)</p>
<p>\(\Longrightarrow \) \(F_2\left( \omega \right)\) 的频谱间隔小</p>
<p>\(\Longrightarrow \) (b)以更密的形式重复</p>
<p>\(\Longrightarrow \) (f)的频谱出现混叠 </p>
<p>\(\Longrightarrow \) 时域上表现为走样</p>
<img title="" src="Rasterization/../assets/周期混叠.jpg" alt="" width="600">
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="反走样算法"><a class="header" href="#反走样算法">反走样算法</a></h1>
<h2 id="提升分辨率采样率-super-sample-aa-ssaa"><a class="header" href="#提升分辨率采样率-super-sample-aa-ssaa">提升分辨率/采样率 Super-sample AA (SSAA)</a></h2>
<p>Super sampling is the most straightforward solution to solve <strong>AA</strong></p>
<img title="" src="Rasterization/../assets/时域采样和频域采样.jpg" alt="" width="536">  
<p>分辨率上升 \(\Longrightarrow \) 像素格子小 \(\Longrightarrow \) 像素采样率上升 \(\Longrightarrow \) （b）间隔大 \(\Longrightarrow \) 混叠少 \(\Longrightarrow \) 减轻走样现象</p>
<p>缺点：受制于物理限制<br />
因此需要思考如何在物理条件不变的情况下解决走样问题</p>
<h2 id="把可能混叠的部分切掉"><a class="header" href="#把可能混叠的部分切掉">把可能混叠的部分切掉</a></h2>
<img title="" src="Rasterization/../assets/采样.jpg" alt="" width="600">
<h3 id="具体方法"><a class="header" href="#具体方法">具体方法：</a></h3>
<ol>
<li>使三角形变模糊，对于三角色形上任意一个像素点：</li>
</ol>
<ul>
<li>原来是根据像素点中心是否在三角形内来判断着色。</li>
<li>现在的做法是，判断整个像素点有多少面积在三角形内来计算着色（卷积）。</li>
</ul>
<p><img src="Rasterization/../assets/32.PNG" alt="" /></p>
<ol>
<li>正常采样</li>
</ol>
<h3 id="局限性"><a class="header" href="#局限性">局限性</a></h3>
<p>面积难以计算</p>
<h2 id="multi-sample-aa-msaa"><a class="header" href="#multi-sample-aa-msaa">Multi-sample AA (MSAA)</a></h2>
<p>Multi Sample Anti-aliasing算法，反走样算法的近似算法</p>
<h3 id="具体方法-1"><a class="header" href="#具体方法-1">具体方法</a></h3>
<table><thead><tr><th>SSAA</th><th>MSAA</th></tr></thead><tbody>
<tr><td><img src="Rasterization/../assets/07-16-1.png" alt="" /></td><td><img src="Rasterization/../assets/07-16-2.png" alt="" /></td></tr>
</tbody></table>
<ol>
<li>Supersampling：一个象素内部划分成多个子（sub）像素 </li>
<li>判断每个子像素是否在三角形内<br />
<img src="Rasterization/../assets/MSAA.jpg" alt="" /></li>
</ol>
<blockquote>
<p>📌 实际在这一步中不会这样均匀的划分，而是采用更合理的方法，在达到效果的同时尽量少地提升计算量。<br />
3. 对判断结果求平均值<br />
<img src="Rasterization/../assets/33.PNG" alt="" /></p>
</blockquote>
<blockquote>
<p>目前硬件部已支持 MSAA。</p>
</blockquote>
<h3 id="局限性-1"><a class="header" href="#局限性-1">局限性</a></h3>
<p>缺点：</p>
<ol>
<li>增加计算量</li>
<li>但现在的高精模型可能比一个像素还小，这种方法就失效了。</li>
</ol>
<blockquote>
<p><strong>❗注意:</strong> Supersampling 与提升分辨率的区别：
本算法并没有实质性地增加像素点</p>
</blockquote>
<h2 id="fxaa-fast-approximate-anti-aliasing"><a class="header" href="#fxaa-fast-approximate-anti-aliasing">FXAA (Fast Approximate Anti-aliasing)</a></h2>
<ol>
<li>用常规方法得到带锯齿图像</li>
<li>通过图像匹配的方法找到边界</li>
</ol>
<p><img src="Rasterization/../assets/07-17-1.png" alt="" /></p>
<ol start="3">
<li>把边界换成没有锯齿的边界</li>
</ol>
<p><img src="Rasterization/../assets/07-17-2.png" alt="" /></p>
<blockquote>
<p>提取边界，并在边界做插值。<br />
优点：(1) 效果好<br />
(2) 速度快，利用 GPU 的并行计算，没有多余的计算。<br />
(3) 计算简单。</p>
</blockquote>
<h3 id="edge-searching-algorithm"><a class="header" href="#edge-searching-algorithm">Edge Searching Algorithm</a></h3>
<p><img src="Rasterization/../assets/07-18-1.png" alt="" /></p>
<p><img src="Rasterization/../assets/07-18-2.png" alt="" /></p>
<h3 id="calculate-blend-coefficient"><a class="header" href="#calculate-blend-coefficient">Calculate Blend Coefficient</a></h3>
<ul>
<li>Compute blender coefficient</li>
</ul>
<p><strong>targetP</strong> is the nearer edge end of <strong>CurrentP</strong></p>
<p><img src="Rasterization/../assets/07-19-2.png" alt="" /></p>
<p><img src="Rasterization/../assets/07-19-5.png" alt="" /></p>
<p><img src="Rasterization/../assets/07-19-4.png" alt="" /></p>
<h3 id="blend-nearby-pixels"><a class="header" href="#blend-nearby-pixels">Blend Nearby Pixels</a></h3>
<ul>
<li>Compute blender coefficient</li>
</ul>
<p><img src="Rasterization/../assets/07-20.png" alt="" /></p>
<p><strong>PixelNewColor = Texture(CurrentP_UV + offset_direction * offset_magnitude )</strong></p>
<h3 id="result"><a class="header" href="#result">Result</a></h3>
<p><img src="Rasterization/../assets/07-21.png" alt="" /></p>
<h2 id="taa-temporal-anti-aliasing"><a class="header" href="#taa-temporal-anti-aliasing">TAA (Temporal Anti-aliasing)</a></h2>
<p>Utilize spatial-<strong>temporal</strong> filtering methods to improve AA stability <strong>in motion</strong></p>
<p>大概意思是，边界上的点，有时显示在上一帧，有时显示在这一帧</p>
<blockquote>
<p>引擎中的主流方法。</p>
</blockquote>
<p><img src="Rasterization/../assets/07-22-1.png" alt="" /></p>
<p><img src="Rasterization/../assets/07-22-2.png" alt="" /></p>
<h3 id="result-1"><a class="header" href="#result-1">Result</a></h3>
<p><img src="Rasterization/../assets/07-23.png" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>采样除了会带来走样问题，还有其它问题。</p>
<h1 id="super-resolution-超分辨率"><a class="header" href="#super-resolution-超分辨率">Super Resolution 超分辨率</a></h1>
<p>问题描述： 低分辨率图拉大成高分辨率出现的锯齿问题<br />
解决方法：DLSS，即Deep Learning Super Sampling</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="背景"><a class="header" href="#背景">背景</a></h1>
<p>有多个物体，每个物体都有多个三角形，因此要处理摭挡问题。</p>
<h1 id="画家算法"><a class="header" href="#画家算法">画家算法</a></h1>
<p><img src="./assets/%E7%94%BB%E5%AE%B6%E7%AE%97%E6%B3%95.jpg" alt="" /></p>
<h2 id="原理"><a class="header" href="#原理">原理</a></h2>
<p>由远及近的在画布上添加新物体，新添加的物体将已有的物体覆盖</p>
<h2 id="主要步骤"><a class="header" href="#主要步骤">主要步骤</a></h2>
<ol>
<li>由远即近排序 O(nlogn)</li>
<li>依次光栅化</li>
</ol>
<h2 id="局限性-2"><a class="header" href="#局限性-2">局限性：</a></h2>
<ol>
<li>难以决定被画对象的深度，深度估计错了，排序就错了，画出来就不对</li>
<li>无法处理深度嵌套的场景
<img src="./assets/34.PNG" alt="" /></li>
</ol>
<h1 id="z-buffer-算法"><a class="header" href="#z-buffer-算法">Z-Buffer 算法</a></h1>
<p>名称：depth buffer， Z buffer，或深度缓存</p>
<blockquote>
<p><strong>📌</strong> 可以解决画家算法无法决定深度的局限性</p>
</blockquote>
<h2 id="原理-1"><a class="header" href="#原理-1">原理</a></h2>
<p>不基于三角形的深度，而是基于像素的深度</p>
<h2 id="预处理"><a class="header" href="#预处理">预处理</a></h2>
<p>由于MVP之后，约定摄像机在坐标原点，物体在视角的z轴负方向，因此物体的z都是负的。为了便于计算，物体上每个点的Z坐标都取其绝对值（深度）。</p>
<p>因此：</p>
<ol>
<li>Z(depth) &gt; 0</li>
<li>Z(depth) 小--&gt;近， Z 大--&gt;远</li>
<li>深度是一个物体距离摄像机的Z轴距离的绝对值。</li>
</ol>
<h2 id="具体步骤"><a class="header" href="#具体步骤">具体步骤</a></h2>
<p>算法过程中维护两个数据:</p>
<ol>
<li>frame buffer：存每个像素点当前绘制的像素值。当算法完成时，这里面的数据就是最终输出结果。</li>
<li>depth buffer：存每个像素点对应的物体上的最小的depth（最近）。当发现在这个像素点上有更近的物体时更新。</li>
</ol>
<p>两个buffer都是逐像素的，因此将buffer数据可视化。<br />
<img src="./assets/zbuffer.jpg" alt="" /></p>
<p><img src="./assets/depthbuffer.jpg" alt="" /></p>
<blockquote>
<p>👆 图中，A点是距离视点（摄像机）较近的点，所以颜色比较黑，B点是距离视点较远的点，所以颜色比较白。距离视点近的像素点，颜色就比较黑，反之比较白，这就是depth/Z buffer。</p>
</blockquote>
<p>伪代码：</p>
<pre><code class="language-python">Initialize depth buffer to ∞
during rasterization：
    for triangle in triangles:
        for (x, y, z) in triangle:
            if z &lt; zbuffer[x, y]:
                framebuffer[x,y] = rgb
                zbuffer[x,y] = z
            else:
                pass
</code></pre>
<ol>
<li>depth buffer 所有像素初始化为无限远</li>
<li>对每个三角形做光栅化，每次绘制三角形时，计算当前像素在三角形上的深度Z
如果Z小于depth buffer上对应点的值，就绘制该点，且更新depth buffer。</li>
</ol>
<blockquote>
<p><strong>📌</strong> 深度缓存发生在每个像素内。</p>
</blockquote>
<h2 id="算法特点"><a class="header" href="#算法特点">算法特点</a></h2>
<ol>
<li>时间复杂为O(n)。</li>
</ol>
<blockquote>
<p>✅<br />
问：为什么能在O(n)复杂度内解决排序问题？<br />
答：这里没有排序。只是找个最值。</p>
</blockquote>
<ol start="2">
<li>与三角形的绘制顺序无关，因此<strong>适合GPU优化</strong></li>
<li>可以与MSAA算法兼容</li>
</ol>
<blockquote>
<p>💡 画家算法是global方法，z-buffer是local方法（贪心）<br />
global要同时考虑所有数据，因此快。local只考虑小范围数据，因此快。<br />
global通常能得到全局最优，但如果只是要一个尽量好（而非最优）的解，考虑到效率、规模的问题，更适合用local。local之间越独立结果越好。<br />
如果global能够完成分解为local，那么毫无疑问选择local，减小问题规模同时能得到最优解。<br />
当前问题属于这一类，因为像素之间是独立的。<br />
local除了能减小问题规模，还可以并行化计算。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="漫反射公式的拓展"><a class="header" href="#漫反射公式的拓展">漫反射公式的拓展</a></h1>
<p><img src="Texture/../assets/38.PNG" alt="" /><br />
图上所有点处于相同的一光照环境下，因此共用同一个着色模型。这是Blinn-Phong模型中计算漫反射项的公式：</p>
<p>\[
L_d=k_d\left( I/r^2 \right) \left( n\cdot l \right) 
\]</p>
<p>但每个点上有不同的颜色，这些不同的颜色，对应公式中的\(k_d\)部分。\(k_d\)就是每个点的不同的属性。</p>
<blockquote>
<p>✅ \(k_d\)可以定义每个点的不同的属性。颜色纹理是其中一种属性。</p>
</blockquote>
<h1 id="纹理-texture"><a class="header" href="#纹理-texture">纹理 Texture</a></h1>
<p>3D物体的表面是2D的。</p>
<img src="Texture/../assets/3D2D.jpg" width = 400 />
<p>纹理：可以看作是一张有弹性、可拉伸的2D图。3D表面与2D图存在一一对应的关系。</p>
<p>纹理映射：是把2D纹理图贴在的物体表面的过程</p>
<p><img src="Texture/../assets/texture.jpg" alt="" /></p>
<p>映射关系：物体表面三角形面片上的顶点（3D坐标），与纹理图上的点（2D坐标）的对应关系。这个映射关系通常由美工生成或者由程序自动化生成。此处假设映射关系是已知的。</p>
<blockquote>
<p>✅ 如何自动生成纹理映射关系是其中一个研究方向。</p>
</blockquote>
<p>纹理坐标：纹理图上的点的坐标，用符号(u, v)表示，u和v的范围都是[0, 1]。不管纹理图实际上有多大，形状是否为正方形。</p>
<p><img src="Texture/../assets/texture2.jpg" alt="" /></p>
<blockquote>
<p>✅ 如何生成可以首尾连接的纹理是其中一个研究方向</p>
</blockquote>
<p>插值：映射关系只包含三角形顶点对应的(u，v)，三角形内部点的(u，v)通过插值得到</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="插值"><a class="header" href="#插值">插值</a></h1>
<p>为什么需要计算三角形内插值？</p>
<p>答：很多特殊值的计算都是只计算顶点，而内部点的值通过插值可以得到平滑的结果。</p>
<p>插值可以用于哪些数据？</p>
<p>答：纹理坐标、颜色、法向量等</p>
<p>三角形内的插值通常使用<strong>重心坐标</strong>。</p>
<h1 id="重心坐标-barycentric-coordinates"><a class="header" href="#重心坐标-barycentric-coordinates">重心坐标 Barycentric Coordinates</a></h1>
<h2 id="什么是重心坐标"><a class="header" href="#什么是重心坐标">什么是重心坐标</a></h2>
<p>重心坐标是定义在一个三角形上的坐标系。具有以下特点：</p>
<ol>
<li><strong>重心坐标不是指某个点的坐标值，而是指一个坐标系。与三角形的重心也没多大关系。</strong></li>
<li>重心坐标定义在一个特定的三角形上。如果换一个坐标系，那么就会得到另一套坐标系。</li>
<li>用这套坐标系可以描述与三角形同平面的所有的点</li>
<li>如果某个点在三角形内部，那么它在这个重心坐标系上的表达会满足某些特点。</li>
</ol>
<h2 id="重心坐标的原理"><a class="header" href="#重心坐标的原理">重心坐标的原理</a></h2>
<img src="Texture/../assets/coordinate.jpg" width = 400 />
<p>假设三角形的三个顶点分别是 A、B、C，则<strong>三角形所在平面上的任意一点可描述为A、B、C的线性组合</strong>，即：</p>
<p>\[
\left( x,y \right) =\alpha A+\beta B+\gamma C
\]</p>
<p>且</p>
<p>$$
\alpha + \beta + \gamma = 1
$$</p>
<p>在这里，\((\alpha, \beta, \gamma)\)就是点(x, y)在这个三角形重心坐标系下的坐标，简称为重心坐标。</p>
<p>如果这个点在三角形内，还需要满足：\(\alpha +\beta +\gamma =1\) ,  \(\alpha \geqslant 0, \beta \geqslant 0,\gamma \geqslant 0\)</p>
<h2 id="特殊点的重心坐标"><a class="header" href="#特殊点的重心坐标">特殊点的重心坐标</a></h2>
<ul>
<li>顶点的重心坐标</li>
</ul>
<p>\[
A=\left( 1,0,0 \right) ,  B=\left( 0,1,0 \right) , C=\left( 0,0,1 \right)
\]</p>
<ul>
<li>三角形重心的重心坐标</li>
</ul>
<p>以2D为例，任意点(x,y)的重心坐标，就是顶点对面的三角形的面积之比，计算公式为：</p>
<p><img src="Texture/../assets/39.PNG" alt="" /></p>
<p>$$
\alpha = \frac{A_A}{A_A + A_B + A_C} \\
\beta = \frac{A_B}{A_A + A_B + A_C} \\
\gamma = \frac{A_C}{A_A + A_B + A_C} 
$$</p>
<p>因此，重心点的重心坐标为：</p>
<p>\[
重心 = \left( \frac{1}{3},\frac{1}{3},\frac{1}{3} \right)
\]</p>
<ul>
<li>任意点的重心坐标</li>
</ul>
<p>\[
\alpha =\frac{-\left( x-x_B \right) \left( y_C-y_B \right) +\left( y-y_B \right) \left( x_C-x_B \right)}{-\left( x_A-x_B \right) \left( y_C-y_B \right) +\left( y_A-y_B \right) \left( x_C-x_B \right)}
\]</p>
<p>\[
\beta =\frac{-\left( x-x_C \right) \left( y_A-y_C \right) +\left( y-y_C \right) \left( x_A-x_C \right)}{-\left( x_B-x_C \right) \left( y_A-y_C \right) +\left( y_B-y_C \right) \left( x_A-x_C \right)}
\]</p>
<p>\[
\gamma =1-\alpha -\beta
\]</p>
<h1 id="利用重心坐标做插值"><a class="header" href="#利用重心坐标做插值">利用重心坐标做插值</a></h1>
<img src="Texture/../assets/重心坐标插值.jpg" width = 500 />
<p>V是三角形内的一个点，根据V的坐标求出其重心坐标为\(\left( \alpha , \beta , \gamma \right) \)</p>
<p>\(V_A, V_B, V_C\)分别是三角形顶点上的属性值，</p>
<p>那么，P点处的属性值为：</p>
<p>\[
V_P=\alpha V_A+\beta V_B+\gamma V_C
\]</p>
<p>优点：计算方便</p>
<p>局限性：空间三角形在平面上投影以后，同一个点在投影前后的重心坐标会改变，因此，插值所使用的重心坐标必须是投影前的重心坐标</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="纹理映射-1"><a class="header" href="#纹理映射-1">纹理映射</a></h1>
<p>目的：把纹理应用到渲染中，使屏幕上的点p=(x,y)呈现出颜色</p>
<ol>
<li>找出p在投影前的坐标p'=(x,y,z)</li>
<li>计算p'的(u,v)，如果p'不是顶点，则需要用到上一节的插值。</li>
<li>从texture中取出(u,v)点的值pv</li>
<li>设置p的值为(u,v)点的值为pv</li>
</ol>
<blockquote>
<p>💡 pv值对应漫反射项公式中的kd，高光项中的ks通常设置为白色。视频中没有说环境光照项中的ka怎么定义，但肯定是跟pv无关的，因为pv是每个点都不同的。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="问题描述"><a class="header" href="#问题描述">问题描述</a></h1>
<p>Texture Map 是256X256的，而要投影的屏幕是4K的，会导致多个屏幕像素(pixel)对应一个纹理像素(texel)。</p>
<h2 id="效果"><a class="header" href="#效果">效果</a></h2>
<img src="Texture/../assets/nearest.jpg" width = 400 />
<h2 id="原因"><a class="header" href="#原因">原因</a></h2>
<img src="Texture/../assets/bilinear.jpg" width = 500 />
<p>上图格子为纹理图，每个格子是一个texel。像素上某点映射到texel的红点位置。常规方法会取红点所在的texel的中心位置的value做为该像素的value。 
同理，所有映射到这个texel上任意位置的pixel，都会得到这个同样的Value。</p>
<h1 id="双线性插值-bilinear-interpolation"><a class="header" href="#双线性插值-bilinear-interpolation">双线性插值 Bilinear Interpolation</a></h1>
<h2 id="原理-2"><a class="header" href="#原理-2">原理</a></h2>
<p>根据红点周围的点的value推断出红点处的value</p>
<ol>
<li>计算出红点的位置(u,v)</li>
<li>取邻近四个纹理像素(a,b,c,d)</li>
<li>再根据(u,v)在a,b,c,d中的位置插值出(u,v)处的值，即分别做一个横向插值和竖向插值</li>
</ol>
<h2 id="具体步骤-1"><a class="header" href="#具体步骤-1">具体步骤</a></h2>
<p>Linear interpolation(1D)：</p>
<p>\[lerp\left( x,v_0,v_1 \right) =v_0+x\left( v_1-v_0 \right) \]</p>
<p>Two helper lerps:</p>
<p>\[u_0=lerp\left( s,u_{00},u_{10} \right) \]</p>
<p>\[u_1=lerp\left( s,u_{01},u_{11} \right) \]</p>
<p>Final vertical lerp, to get result:</p>
<p>\[f\left( x,y \right) =lerp\left( t,u_0,u_1 \right) \]</p>
<h2 id="效果-1"><a class="header" href="#效果-1">效果</a></h2>
<p>虽然还有点模糊，但不是颗粒感的</p>
<img src="Texture/../assets/bilinear2.jpg" width = 400 />
<blockquote>
<p>💡 插值就是以距离为权重求加权平均，加权平均能增加平滑但导致模糊。</p>
</blockquote>
<h1 id="双向三次插值-bicubic"><a class="header" href="#双向三次插值-bicubic">双向三次插值 Bicubic</a></h1>
<ol>
<li>取周围16个点</li>
<li>三阶插值</li>
</ol>
<p>效果：</p>
<img src="Texture/../assets/bicubic.jpg" width = 400 />
<blockquote>
<p>💡 一次插值剂量不够就再插一次。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="问题描述-1"><a class="header" href="#问题描述-1">问题描述</a></h1>
<h2 id="现象"><a class="header" href="#现象">现象</a></h2>
<p>纹理像素分辨率过大，比被贴图的表面更精细，也会出现问题。例如：</p>
<img src="Texture/../assets/problem2.jpg" width = 600 />   
<blockquote>
<p>👆 左：期待效果 右：实际效果</p>
</blockquote>
<h2 id="原因-1"><a class="header" href="#原因-1">原因</a></h2>
<p>由于透视的原因，不同距离的屏幕像素对应的纹理像素区域不同</p>
<p><img src="Texture/../assets/footprint.jpg" alt="" /></p>
<blockquote>
<p><strong>👆</strong> 有的像素对应一小部分纹理像素，有的像素对应较大区域的纹理像素</p>
</blockquote>
<ul>
<li>在近处，物体表面比纹理图更精细，即Texture Magnification问题，见上一页，表现为锯齿。</li>
</ul>
<blockquote>
<p>🔎<a href="Texture/TextureMagnification.html">Texture Magnification</a></p>
</blockquote>
<ul>
<li>在远处，纹理图比物体表面精细，一个屏幕像素对应一片纹理像素，但只取一个纹理像素来代表这一片点，也会出现问题，表现为摩尔纹</li>
</ul>
<p>进一步解释，从纹理图中取一个texel的过程可以看作是对纹理图的采样。alias的本质是信号变化过快而采样跟不上信号变化的速度。纹理的变化快而采样点稀疏就导致了这种现象。</p>
<blockquote>
<p>💡 两个空间的映射，任何一方的不匹配都会现alias，那就对变化快的一块做平均，或对变化慢的一方做细分。</p>
</blockquote>
<h1 id="解决方法一超采样-msaa"><a class="header" href="#解决方法一超采样-msaa">解决方法一：超采样 MSAA</a></h1>
<blockquote>
<p>🔎<a href="Texture/../Rasterization/AntialiasingMore.html">MSAA</a></p>
</blockquote>
<ul>
<li>原理</li>
</ul>
<p>对于远处的一个点，取512个texel的value的平均值。</p>
<ul>
<li>效果</li>
</ul>
<p><img src="Texture/../assets/40.PNG" alt="" /></p>
<ul>
<li>局限性</li>
</ul>
<p>可解决，但costly。</p>
<h1 id="解决方法二-mip-map"><a class="header" href="#解决方法二-mip-map">解决方法二： Mip map</a></h1>
<h2 id="原理-3"><a class="header" href="#原理-3">原理</a></h2>
<p>点查询（采样）--&gt;范围查询（取一个范围的平均）。</p>
<blockquote>
<p>📌<br />
范围查询的应用场景非常广泛，除了CG，还有其它很多领域会用到。<br />
范围查询的目标也有多种，例如取范围内的最大值、最小值、平均值。在这里要查的是平均值。<br />
范围查询的算法也有很多种，在当前场景下使用同MIP Map算法来做范围平均值的查询。</p>
</blockquote>
<h2 id="mip-map算法"><a class="header" href="#mip-map算法">Mip Map算法</a></h2>
<ul>
<li>作用：用于范围内平均值的查询</li>
<li>特点：快，不精确（近似），只能查询正方形区域</li>
</ul>
<ol>
<li>
<p>原始纹理称为第0层纹理，根据第0层纹理预先生成出第1-7层纹理。每一层都是上一层缩小一倍。1-7层低分辨率纹理总共仅消耗额外1/3存储。</p>
<p><img src="Texture/../assets/mip.jpg" alt="" /></p>
</li>
<li>
<p>找出屏幕上的一个像素对应的纹理上的近似方形区域。</p>
<p><img src="Texture/../assets/mipmap3.jpg" alt="" /></p>
</li>
</ol>
<p><strong>第一步：画出像素对应的四边形区域</strong></p>
<p>已知某像素及其邻居像素对应的texel的位置。像素与上面邻居像素对应的texel位置的中线，认为是像素对应的texel的上边界。<br />
以这种方法，可以在纹理上画出一个不规则四边形区域。</p>
<p><img src="Texture/../assets/41.PNG" alt="" /></p>
<p><strong>第二步：用一个正方形来近似这个不规则四边形区域。</strong></p>
<p><img src="Texture/../assets/42.PNG" alt="" /></p>
<p>边长L为：</p>
<p>$$
L = \max(\sqrt{(\frac{du}{dx})^2+(\frac{dv}{dx})^2}, \sqrt{(\frac{du}{dy})^2+(\frac{dv}{dy})^2})
$$</p>
<blockquote>
<p>❓ 问：这个公式没有看懂。x和y分别是指什么呢？公式里的变化量是什么呢？是什么和什么之间取最大值？<br />
✅ 答：x和y分别是两个邻居。L是当前texel与两个邻居之间的距离的最大值。（为什么是两个？为什么是这两个邻居？）公式中的两项，分别代表当前texel和x、y的距离。距离是用勾股定理算出来的。里面的微分量是当前texel到邻居的位置变化，分别对应横轴的变化和纵轴的变化。<br />
这只是一种近似方法。可以用其它达到近似目的的方法。</p>
</blockquote>
<ol start="3">
<li>根据mipmap计算边长为L的纹理方形区域的均值。边长为L的方形区域，会在第\(\log_2L\)层变成一个像素。直接查在\(\log_2L\)层纹理上查(u,v)的值即可。</li>
</ol>
<p><img src="Texture/../assets/43.PNG" alt="" /></p>
<h2 id="效果-2"><a class="header" href="#效果-2">效果</a></h2>
<p><img src="Texture/../assets/mipmapresult.jpg" alt="" /></p>
<blockquote>
<p>👆 不同颜色代表查询不同的层。</p>
</blockquote>
<p>整体上颜色变化反应了需要的纹理大小。但是，存在两层之间的边界，边界处可能存在突变。</p>
<blockquote>
<p>💡 提前算好部分范围的值，结果是不同范围的组合。<br />
空间换时间，要想换得好，就要能分解出可以提前计算的部分，且这部分满足：</p>
<ol>
<li>是计算的瓶颈</li>
<li>不依赖输入</li>
<li>分解与组合方便</li>
</ol>
</blockquote>
<h1 id="改进三线性插值"><a class="header" href="#改进三线性插值">改进：三线性插值</a></h1>
<h2 id="原理-4"><a class="header" href="#原理-4">原理</a></h2>
<p>这是一种基于mip map的改进，把层数变成一个连续的值，能够解决层数边界上的突变</p>
<p>方法：根据层数再做一次插值，例如需要计算第1.8层的值，就把第1层的插值结果与第2层的插值结果再做一次插值</p>
<p><img src="Texture/../assets/44.PNG" alt="" /></p>
<h2 id="效果-3"><a class="header" href="#效果-3">效果</a></h2>
<p><img src="Texture/../assets/mipmapresult2.jpg" alt="" /></p>
<blockquote>
<p>👆 不同颜色代表查询不同的层。层与层之间存在渐变的过渡。</p>
</blockquote>
<blockquote>
<p>💡 层数很明显是离散信息，连续的层数没有意义，但可以用来插值。总之，万物皆可插。</p>
</blockquote>
<p>回到原来那个问题，假设把512超采样的结果看作是这个问题的GT，对比三线性插值后的效果：</p>
<table><thead><tr><th>512超采样</th><th>三线性插值</th></tr></thead><tbody>
<tr><td><img src="Texture/../assets/45.PNG" alt="" /></td><td><img src="Texture/../assets/46.PNG" alt="" /></td></tr>
</tbody></table>
<p>远处没有摩尔纹，但是变成了一片灰色，这种情况称为overblur。<br />
这是因为mipmap只能计算方形区域。而根据上图可以看出，屏幕的方形区域不对应纹理图上的方形区域。</p>
<h1 id="改进ripmap各项异性过滤anisotropic-littering"><a class="header" href="#改进ripmap各项异性过滤anisotropic-littering">改进：Ripmap：各项异性过滤(Anisotropic littering)</a></h1>
<h2 id="原理-5"><a class="header" href="#原理-5">原理</a></h2>
<p>MipMap只预计算图中对角线上的图片，它假设纹理是按同比例压缩的。但事实上不是这样。</p>
<p><img src="Texture/../assets/47.PNG" alt="" /></p>
<blockquote>
<p>👆 屏幕的方形区域实际上是对应纹理空间的不规律形状，如果用正方形来代表这长条，会发生过渡blur。 </p>
</blockquote>
<blockquote>
<p>💡 如果我来解这个问题，我会把一个倾斜成多个大小不同的正方式。再以正方形的大小为权重对正方形结果求平均。</p>
</blockquote>
<p>各项异性过滤对原始纹理做不均匀压缩，这样，就可以查询到在纹理上一块长形区域，或宽形区域的值。 </p>
<p><img src="Texture/../assets/anisotropic.jpg" alt="" /></p>
<p>各项异性过滤能解决水平或竖直长方形的问题，不能解决倾斜长方形的问题。</p>
<p>存储开销增加了3倍。</p>
<h1 id="改进ewa-filtering"><a class="header" href="#改进ewa-filtering">改进：EWA Filtering</a></h1>
<p><img src="Texture/../assets/EWA.jpg" alt="" /></p>
<ol>
<li>把不规则形状拆成很多不同的<strong>圆形</strong>去覆盖这个不规则形状。</li>
<li>每次查询一个圆形区域，进行多次查询。</li>
</ol>
<blockquote>
<p>❓ 为什么是圆形？</p>
</blockquote>
<p>特点：质量越好，代价越大</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="硬阴影-vs-软阴影"><a class="header" href="#硬阴影-vs-软阴影">硬阴影 Vs 软阴影</a></h1>
<table><thead><tr><th>硬阴影</th><th>软阴影</th></tr></thead><tbody>
<tr><td><img src="Shadow/../assets/80.PNG" alt="" /></td><td><img src="Shadow/../assets/81.PNG" alt="" /></td></tr>
<tr><td>边缘锐利</td><td>边缘慢慢过渡</td></tr>
</tbody></table>
<p>软阴影的形成原因：半影，光源较大，部分光源被挡住</p>
<p><img src="Shadow/../assets/82.PNG" alt="" /></p>
<blockquote>
<p>✅ 从面光源的不同位置看向物理，得到的z-buffer是不同的。第一步只能记录一个点相关的z-buffer，因此无法处理面光源。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shadow-mapping-算法"><a class="header" href="#shadow-mapping-算法">Shadow Mapping 算法</a></h1>
<p>Shadow Mapping是一种基于光栅化的生成阴影的经典算法。</p>
<h3 id="原理-6"><a class="header" href="#原理-6">原理</a></h3>
<p>如果一个点不在阴影里，那么必须同时满足：</p>
<ul>
<li>人（camera）可以看见点</li>
<li>光源可以看见点</li>
</ul>
<h3 id="具体步骤-2"><a class="header" href="#具体步骤-2">具体步骤：</a></h3>
<ol>
<li>从光源看向场景，记录能看到的点的深度(shadow map)。</li>
</ol>
<p><img src="Shadow/../assets/69-17.png" alt="" /></p>
<blockquote>
<p>✅ 找到满足“光源可以看见”的点</p>
</blockquote>
<ol start="2">
<li>从眼睛看向场景，记录眼睛能看到的点。</li>
</ol>
<blockquote>
<p>✅ 找到满足“相机可以看见”的点</p>
</blockquote>
<ol start="3">
<li>把眼睛能看到的点投影回step1记录的深度图上，即推出它会出现在深度图的哪个像素上</li>
</ol>
<blockquote>
<p>✅ 计算点在“光源视角”和“相机视角”的对应关系</p>
</blockquote>
<ol start="4">
<li>如果点到光源的深度与叫step1记录的这个方向的深度一致，
则：这个点可被光源和 camera 同时看到，不在阴影中。否则：在阴影中</li>
</ol>
<blockquote>
<p>✅ 分析点是否满足“阴影条件”</p>
</blockquote>
<table><thead><tr><th>不在阴影中</th><th>在阴影中</th></tr></thead><tbody>
<tr><td><img src="Shadow/../assets/74.PNG" alt="" /></td><td><img src="Shadow/../assets/75.PNG" alt="" /></td></tr>
</tbody></table>
<h3 id="效果-4"><a class="header" href="#效果-4">效果</a></h3>
<p>光源是左上角的白点</p>
<p><img src="Shadow/../assets/76.PNG" alt="" /></p>
<h3 id="特点"><a class="header" href="#特点">特点</a></h3>
<p>Shadow Mapping算法具有以下特点：</p>
<ul>
<li>在生成阴影的这一步，不需要知道场景的几何信息</li>
<li>走样现象</li>
<li>该算法只能处理点光源</li>
</ul>
<blockquote>
<p>❓ 为什么说不需要知道场景的几何信息呢？第一步和第二步都用到场景的几何信息了啊。<br />
✅ 点光源产生硬阴影，面光源产生软阴影。</p>
</blockquote>
<h3 id="存在点的问题"><a class="header" href="#存在点的问题">存在点的问题</a></h3>
<ol>
<li>step 4判断距离是否相等，但距离是浮点数，浮点数有精度问题</li>
<li>深度图的采样频率和渲染的采样频率一致，会引发 artifacts.</li>
<li>增加一遍渲染</li>
</ol>
<blockquote>
<p>❓ 怎么理解增加一遍渲染，不能同时渲染吗？</p>
</blockquote>
<ol start="4">
<li>只能做硬阴影（点光源）</li>
</ol>
<p><img src="Shadow/../assets/69-19.png" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="big-world-and-cascade-shadow"><a class="header" href="#big-world-and-cascade-shadow">Big World and Cascade Shadow</a></h2>
<ul>
<li>Partition the frustum into multiple frustums</li>
<li>A shadow map is rendered for each sub frustum</li>
<li>The pixel shader then samples from the map that most closely matches the required resolution</li>
</ul>
<p><img src="Shadow/../assets/69-71.png" alt="" /></p>
<blockquote>
<p>不同远近的物体的 shadow，对精度的要求是不一样的。这样，近处 shadow 足够清晰，远处 shadow 足够稀疏。</p>
</blockquote>
<h2 id="blend-between-cascade-layers"><a class="header" href="#blend-between-cascade-layers">Blend between Cascade Layers</a></h2>
<ol>
<li>A visible seam can be seen where cascades overlap</li>
<li>between cascade layers because the resolution does not match</li>
<li>The shader then linearly interpolates between the two values based on the pixel's location in the blend band</li>
</ol>
<h2 id="pros-and-cons-of-cascade-shadow"><a class="header" href="#pros-and-cons-of-cascade-shadow">Pros and Cons of Cascade Shadow</a></h2>
<ul>
<li>Pros
<ul>
<li>best way to prevalent errors with shadowing: perspective aliasing</li>
<li>fast to generate depth map, 3x up when depth writing only</li>
<li>provide fairly good results</li>
</ul>
</li>
<li>Cons
<ul>
<li>Nearly impossible to generate high quality area shadows</li>
<li>No colored shadows. Translucent surfaces cast opaque shadows</li>
</ul>
</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shading-着色"><a class="header" href="#shading-着色">Shading 着色</a></h1>
<p><img src="Shading/../assets/35.PNG" alt="" /></p>
<blockquote>
<p>👆 把前面的步骤串起来，是这样子的过程</p>
</blockquote>
<p>经过前面这些步骤后，能这得到这样的结果：</p>
<p><img src="Shading/../assets/%E7%9D%80%E8%89%B2%E5%AF%B9%E6%AF%94.jpg" alt="" /></p>
<blockquote>
<p>👆 （左）不考虑着色的效果；（右）期望达到的效果。</p>
</blockquote>
<p>纯色立方体的每个面每个时刻呈现的颜色有变化。使整体效果更真实。</p>
<blockquote>
<p><strong>📌</strong> 为什么纯色物体的不同时刻和不同位置，其颜色看不去会不同？<br />
答：颜色是差别是物体的材质与光源作用的结果。同一时刻，不同位置上的像素点，与光源的关系不同，呈现的颜色就会不同。不同时刻，光源发生了变化，同一像素点与光源的关系也变了，导致呈现出的颜色的变化。</p>
</blockquote>
<p>根据物体的材质，以及物体与光源的关系，对物体的颜色加以调整，这个过程就是着色。</p>
<p>即：The process of applying a material to an object.</p>
<p>本课程中不包含给object添加投影的过程。</p>
<h1 id="渲染方程"><a class="header" href="#渲染方程">渲染方程</a></h1>
<p><img src="Shading/../assets/v2-78547d4764131258e357a7cedab05711_r.png" alt="" /></p>
<p>这是著名的Render Equation ，我们今天几乎做的所有Rendering 相关的工作都是去满足这个Render Equation 。但是至今为止，没有任何一款游戏引擎能够做到实时的完全按照Render Equation来进行渲染，我们能做到的只是在无限的逼近它。</p>
<p><img src="Shading/../assets/v2-75ea529e0b2f17fa8d47b69cd4bd92ec_r.png" alt="" /></p>
<p>在具体实践中，这个方程会变得非常复杂：</p>
<ul>
<li>物体会被来自四面八方的光照射</li>
<li>物体也会向四面八方的光照射</li>
<li>MultiBounce：光路上可能会有很多次反射和折射</li>
<li>不同材质的物体，会有不同的反射和折射效果</li>
<li>次表现反射：透明物体，光射入物体后会在物体内部反射，并另在一个位置射出</li>
<li>高光</li>
<li>color bleeding</li>
<li>....</li>
</ul>
<p>最重要的是，这些都必须在有限的资源、有限的时间、有限的算力下完成。</p>
<h2 id="挑战"><a class="header" href="#挑战">挑战</a></h2>
<ul>
<li>1a: Visibility to Light。
人眼通常要靠明暗关系、摭挡关系来判断层次结构。但是Shadow很难做。</li>
<li>1b: 光源很复杂。
有平行光（无穷远，例如太阳）、点光源、锥形光源（例如路灯）、面光源<br />
光有不同的强度、方向</li>
</ul>
<p>关于radiance和irradiance看<a href="https://caterpillarstudygroup.github.io/GAMES101_mdbook/RayTracing/BasicRadiometry.html">这里</a></p>
<ul>
<li>2：材质BRDF和光的积分</li>
<li>3：物体受到照射后会反射出光，所以场景中会有无穷多个“光源”，使方程变成了无限递归的总是</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>Basic Radiometry 辐射度量学，是对光的物理性质精准建模的方法。因此能够得到更真实的效果。</p>
<ol>
<li>定义了一系列方法和单位</li>
<li>给光定义了各种空间中的属性</li>
<li>基于几何光学，认为光沿直接传播，无波动性</li>
</ol>
<h1 id="定义"><a class="header" href="#定义">定义</a></h1>
<p><strong>这是一种基于物理的方法。首先对光的单位和属性做一些定义</strong></p>
<table><thead><tr><th>定义</th><th>说明</th><th>符号</th><th>单位</th><th>关系</th></tr></thead><tbody>
<tr><td>Radiant Energy</td><td>能量，光源辐射出来的是Energy</td><td>Q</td><td>J</td><td></td></tr>
<tr><td>Radiant Flux</td><td>power，即单位时间的能量</td><td>\(\Phi\)</td><td>Watt或lumen</td><td>\(\Phi = \frac{dQ}{dt}\)</td></tr>
<tr><td>Radiant Intensity</td><td>power per unit solid angle，即单位时间单位面积上的能量</td><td>I</td><td>\([\frac{W}{Sr}]\)</td><td>\(I(\omega) = \frac{d(\Phi)}{d\omega}\)，其中分子代码power，分母代表per unit solid angle</td></tr>
<tr><td>Irradiance</td><td>power per unit area</td><td>E</td><td>\([\frac{W}{m^2}]\)</td><td>\(E(x) = \frac{d(\Phi(x))}{dA}\)，其中A代表光线垂直接触的面积</td></tr>
<tr><td>Radiance</td><td>power per unit solid angle per unit area</td><td>L</td><td>\([\frac{W}{Srm^2}]\)</td><td>\(L(p, \omega) = \frac{d^2(\Phi(p, \omega))}{d\omega dA\cos\theta}\)</td></tr>
</tbody></table>
<h1 id="radiant-intensity"><a class="header" href="#radiant-intensity">Radiant Intensity</a></h1>
<p>power per unit solid angle(立体角)，光源向外辐射能量时与方向有关的辐射概念。</p>
<p>$$
I(\omega) = \frac{d(\Phi)}{d\omega}
$$</p>
<h2 id="立体角"><a class="header" href="#立体角">立体角</a></h2>
<p>通常使用弧度制来描述一个角。立体角是2D角度在3D空间中的延伸。用来描述空间中的一个角有多大。</p>
<h3 id="2d角"><a class="header" href="#2d角">2D角</a></h3>
<p><img src="RayTracing/../assets/113.PNG" alt="" /></p>
<p>$$
\theta = \frac{l}{r}, \in [0, 2\pi]
$$</p>
<h3 id="3d立体角"><a class="header" href="#3d立体角">3D立体角</a></h3>
<p><img src="RayTracing/../assets/114.PNG" alt="" /></p>
<p>$$
\Omega = \frac{A}{r^2}, \in [0, 4\pi]
$$</p>
<h3 id="单位立体角"><a class="header" href="#单位立体角">单位立体角</a></h3>
<p>即球面上的单位面积与除以半径平方。</p>
<p><img src="RayTracing/../assets/115.PNG" alt="" /></p>
<blockquote>
<p>✅ 单位立体角是某个固定大小的立体角。</p>
</blockquote>
<ol>
<li>通过\(\theta\)和\(\phi\)定义球面上的一个方向。</li>
</ol>
<blockquote>
<p>✅ 假设朝右的是x轴，朝上的是y轴，朝前的是z轴。从图上看，应该是先<strong>以y为轴把坐标系</strong>（不是把y轴）顺时针转\(\phi\)，然后以z为轴把坐标系顺时针转\(\theta\)得到一个新的坐标系。所定义的朝向是新坐标系中的y轴正方向在原坐标系中的朝向。</p>
</blockquote>
<ol start="2">
<li>计算这个方向上的单位面积</li>
</ol>
<blockquote>
<p>❓ 怎么就从这个方向得到了这个矩形？　</p>
</blockquote>
<p>假设这个区域是个矩形，横边的长度是\(r \sin \theta d\phi\)，竖边的长度是\(r d\theta\)</p>
<blockquote>
<p>✅ 这里反向利用了2D角度公式\(\theta = \frac{l}{r}\)<br />
竖边是以r为半径的2D圆，大小为\(d\theta\)的2D角对应的弧长。<br />
横边是以\(r \sin \theta\)为半径的2D圆，大小为\(d\phi\)的2D角对应的弧长。</p>
</blockquote>
<p>$$
dA = (r d\theta) (r \sin \theta d\phi) = r^2 \sin \theta d \theta d \phi
$$</p>
<ol start="3">
<li>计算单位立体角</li>
</ol>
<p>根据定义可知：</p>
<p>$$
d\omega = \frac{dA}{r^2} = \sin \theta d \theta d \phi
$$</p>
<blockquote>
<p>❗ 后面内容将会用\(\omega\)来表示空间的一个方向。且\(\omega\)可通过\(\theta\)和\(\phi\)来定义。</p>
</blockquote>
<h2 id="再看intensity"><a class="header" href="#再看intensity">再看Intensity</a></h2>
<p>Intensity = Flux per unit solid angle，代表了光源在某个方向上的量度。</p>
<p>$$
I(\omega) = \frac{d(\Phi)}{d\omega}
$$</p>
<p>反过来说，Flux是Intensity在各个方向上的积分，因此</p>
<p>$$
\Phi = \int_{S^2} I d\omega = 4\pi I \\
I = \frac{\Phi}{4\pi}
$$</p>
<h1 id="irradiance"><a class="header" href="#irradiance">Irradiance</a></h1>
<p>power per unit area，表示物体在单位面积上接收到的能量。</p>
<p>$$
E(x) = \frac{d(\Phi(x))}{dA}
$$</p>
<blockquote>
<p>❗ 面积是指与入射光线垂直的区域的面积。如果物体表面与入射光线不垂直，则需要乘以\(\cos \theta\)</p>
</blockquote>
<table><thead><tr><th>入射角</th><th>Irradiance</th></tr></thead><tbody>
<tr><td><img src="RayTracing/../assets/116.PNG" alt="" /></td><td>\(E(x) = \frac{\Phi}{A}\)</td></tr>
<tr><td><img src="RayTracing/../assets/117.PNG" alt="" /></td><td>\(E(x) = \frac{1}{2}\frac{\Phi}{A}\)</td></tr>
<tr><td><img src="RayTracing/../assets/118.PNG" alt="" /></td><td>\(E(x) = \frac{\Phi}{A}\cos\theta\)</td></tr>
</tbody></table>
<h2 id="intensity-vs-irradiance"><a class="header" href="#intensity-vs-irradiance">Intensity VS Irradiance</a></h2>
<p><img src="RayTracing/../assets/18.PNG" alt="" /></p>
<p>Intensity为光源向某个立体角辐射的能量，与距离无关。因此Intensity不会随着距离变远而衰减，始终是\(\frac{\Phi}{4\pi}\)</p>
<p>Irradiance为单位面积上接收到的能量。距离越远，总面积越大，单位面积上的能量就会越小。因此Irradiance会随着距离变远而衰减，为\(\frac{E}{r^2}\)。</p>
<h1 id="radiance"><a class="header" href="#radiance">Radiance</a></h1>
<p>Radiance<br />
= power per unit solid angle per projected unit area<br />
= Irradiance per solid angle<br />
= Intensity per projected unit area</p>
<p>用于描述光线在传播过程中的属性。</p>
<p>$$
L(p, \omega) = \frac{d^2(\Phi(p, \omega))}{d\omega dA\cos\theta}
$$</p>
<p><img src="RayTracing/../assets/119.PNG" alt="" /></p>
<p>考虑一个朝向为\(\theta\)的区域dA，朝方向\(\omega\)上辐射的能量。</p>
<h2 id="radiance-vs-irradiance"><a class="header" href="#radiance-vs-irradiance">Radiance Vs Irradiance</a></h2>
<p>Radiance = Irradiance per solid angle</p>
<p>$$
L(p, \omega) = \frac{dE(p)}{d\omega\cos\theta}
$$</p>
<ul>
<li>理解1：</li>
</ul>
<p>dA区域的能量会向各个方向辐射，辐射的总能量为Irradiance，Radiance描述其中向\(\omega\)辐射的能量有多少</p>
<ul>
<li>理解2：</li>
</ul>
<p><img src="RayTracing/../assets/120.PNG" alt="" /></p>
<p>dA区域会接收来自各个方向的能量，接收到的总能量为Irradiance，其中来自\(\omega\)方向的能量为Radiance。</p>
<ul>
<li>反过来理解</li>
</ul>
<p>Irradiance是区域dA从不同角度收到的Irradiance的积分。</p>
<p><img src="RayTracing/../assets/121.PNG" alt="" /></p>
<p>$$
E(p) = \int_{H^2}L_i(p, \omega)\cos\theta d\omega
$$</p>
<blockquote>
<p>✅ \(H^2\)代表上半球，不考虑来自背面的光</p>
</blockquote>
<h2 id="radiance-vs-intensity"><a class="header" href="#radiance-vs-intensity">Radiance Vs Intensity</a></h2>
<p>Radiance = Intensity per projected unit area</p>
<p>$$
L(p, \omega) = \frac{dI(p, \omega)}{dA\cos\theta}
$$</p>
<p>与上面类似，也可以有三种理解方式</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brdf-双向反射分布函数"><a class="header" href="#brdf-双向反射分布函数">BRDF, 双向反射分布函数</a></h1>
<p>Bidirectional Reflected Distribution Function</p>
<p>输入：一个入射光线的角度和能量<br />
输出：各个反射光线的能量分布，包含镜面反射和漫反射</p>
<h2 id="反射"><a class="header" href="#反射">反射</a></h2>
<p>反射可以理解为从某个入射角度\(\omega\)打到指定区域的能量radiance。<br />
这些radiance被区域吸收，并从这个区域向各个方向辐射。</p>
<blockquote>
<p>✅ 从吸收的视角来理解是radiance，从辐射的视角来理解是irradiance，但是所承载的能量大小是相同的。</p>
</blockquote>
<h2 id="brdf"><a class="header" href="#brdf">BRDF</a></h2>
<p>BRDF则描述了这些irradiance会如何分配到各个立体角上去，即向某个方向辐射的radiance。<br />
BRDF用比例的方式来描述这种分配关系。提供某个立体角上的radiance占的irradiance的多少。</p>
<blockquote>
<p>💡 老师没有详细介绍BRDF是什么样的函数。我理解就是一个概率密度函数。漫反射是均匀概率，高光是高斯概率。</p>
</blockquote>
<p><img src="RayTracing/../assets/122.PNG" alt="" /></p>
<p>以上图为例：<br />
从\(\omega_i\)向指定区域辐射到的能量，也可以说是指定区域从\(\omega_i\)方向吸收到的能量，为：</p>
<p>$$
dE(\omega_i) = L(\omega_i)\cos\theta_i d\omega_i
$$</p>
<p>这些吸收到的能量又从这个区域被辐射出去，向\(\omega_r\)方向辐射的能量为：</p>
<p>$$
dL_r(\omega_r)
$$</p>
<p>BRDF为“从某个角度辐射的能量”与“来自某个入射角度并向所有角度辐射的总能量”的比例，或者说是“从某个角度辐射的能量”与“从某个角度接收的能量”的比例：</p>
<p>$$
f_r(w_i\rightarrow w_r) = \frac{dL_r(w_r)}{dE_i(w_i)} = \frac{dL_r(w_r)}{L_i(w_r)\cos\theta_idw_i}
$$</p>
<p>其中分子表示unit area向\(\omega_r\)辐射的能量，分母表示unit area从\(\omega_i\)接收到的能量</p>
<p>不同的材质会有不同BRDF。</p>
<h1 id="反射方程"><a class="header" href="#反射方程">反射方程</a></h1>
<p>BRDF为描述某个角度入射光对某个角度出射光的能量贡献，把得到入射角度都积分起来，得到是这个区域往某个角度辐射的能量总量。</p>
<p>$$
L_r(p,w_r) = \int_{H^2}f_r(p, w_i\rightarrow w_r)L_i(p, w_i)\cos\theta_idw_i
$$</p>
<p>其中：<br />
\(\int ... dw_i\)：对所有入射方向的积分,，每个入射角wi对同一出射方向wr的贡献的累积<br />
\(L_i(p, w_i)\)：这个入射方向的打到区域的能量，是radiance<br />
\(\cos\theta_i\)：考虑入射方向与被辐射区域的夹角<br />
\(fr(p, w_i\rightarrow w_r)\)：把radiance分给某个出射角</p>
<blockquote>
<p>❓ [?] p是什么？代表这个区域？</p>
</blockquote>
<blockquote>
<p>❗ 任何的出射的 radiance 都会变成其它的入射的 radiance，即公式中的 \(L_i(p, w_i)\)不一定来自光源。
因此，<strong>这是一个递归问题</strong>。</p>
</blockquote>
<blockquote>
<p>💡 把渲染过程中的量抽象成符号并归纳成公式，这就是刘老师所说的对问题建模的能力。<br />
同一问题，建了什么样的模型就能得到什么样的结果，因此建模的能力是最重要的。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="渲染方程-1"><a class="header" href="#渲染方程-1">渲染方程</a></h1>
<p>Lo(p, wo) = 自己发光 + 来自其它的反射或直射光。</p>
<p>$$
L_o(p,w_o) = L_e(p,w_o) + \int_{\Omega^+}L_i(p, w_i)f_r(p, w_i, w_r)(n \cdot \omega_i)dw_i
$$</p>
<p>说明：<br />
\(H^2\)或\(\Omega^+\)：都是表示上半球。定义的积分域为上半球，即不考虑折射。<br />
\((n \cdot \omega_i)\)：和\(\cos\theta\)是一个意思。参考<a href="RayTracing/../Dependency/Vector.html">link</a><br />
第一项：自己发光超某个方向辐射的能量。<br />
第二项：从各个角度来的反射光或直射光向某个方向辐射的能量。</p>
<h1 id="理解11个入射光线"><a class="header" href="#理解11个入射光线">理解1：1个入射光线。</a></h1>
<p><img src="RayTracing/../assets/123.PNG" alt="" /></p>
<p>$$
L_o(x,w_r) = L_e(x, w_r) + L_i(x, w_i)f(x, w_i, w_r)(n \cdot \omega_i)
$$</p>
<blockquote>
<p>👆 原视频公式中有两个错误：<br />
折射光Lr不包含自己发光项。Lo才是reflect和emission之和。<br />
最后一项角度用点号不用逗号。<br />
✅ 只考虑一根入射光线的情况不需要积分</p>
</blockquote>
<h1 id="理解2多个入射光线"><a class="header" href="#理解2多个入射光线">理解2：多个入射光线</a></h1>
<p><img src="RayTracing/../assets/124.PNG" alt="" /></p>
<p>$$
L_o(x,w_r) = L_e(x, w_r) + \sum L_i(x, w_i)f(x, w_i, w_r)(n \cdot \omega_i)
$$</p>
<p>把多个入射光的贡献加起来</p>
<h1 id="理解31个面光源"><a class="header" href="#理解31个面光源">理解3：1个面光源</a></h1>
<p><img src="RayTracing/../assets/125.PNG" alt="" /></p>
<p>$$
L_o(p,w_r) = L_e(p,w_r) + \int_{\Omega}L_i(p, w_i)f(p, w_i, w_r)(n \cdot \omega_i)dw_i
$$</p>
<p>面光源可以看作是无穷多个小的点光源的积分。<br />
因此单个点光源的累加变成了\(d\omega_i\)的积分。</p>
<h1 id="理解4来自其它物体的反射光作为入射光线"><a class="header" href="#理解4来自其它物体的反射光作为入射光线">理解4：来自其它物体的反射光作为入射光线</a></h1>
<p><img src="RayTracing/../assets/126.PNG" alt="" /></p>
<p>x是X物体上的一个点，X'是另一个物体。<br />
\(L_r(X', -\omega_i)\)是X'发出（自身发光或反射）的光以\(\omega_i\)角度辐射x<br />
\(L_r(X, \omega_o)\)是X发出（自身发光或反射）辐的光，可能也在以某个角度辐射另一个物体。</p>
<h1 id="递归问题"><a class="header" href="#递归问题">递归问题</a></h1>
<p>把“理解4”中的公式简化，得：</p>
<p>$$
l(u) = e(u) + \int l(v)K(u,v)dv
$$</p>
<p>其中：<br />
l(u)：未知量<br />
e(u)：自己发的光<br />
I(v)：未知量<br />
K(u,v)dV：材料属性</p>
<p>进一步简化得到公式的算子形式:</p>
<p>$$
L = E + K L 
$$</p>
<p>解得:</p>
<p>$$
L = E + KE + K^2E + k^3E + \dots
$$</p>
<p>其中：<br />
E：光源直接发出的能量<br />
KE：光源辐射能量经过一次反射后的能量，又称为直接光照<br />
\(K^nE\)：多次反射，统称为间接光照<br />
全局光照：直接光照与间接光照的集合<br />
光栅化中的着色：包含光源和直接光照，不包含间接光照，因此效果有限</p>
<h1 id="效果-5"><a class="header" href="#效果-5">效果</a></h1>
<ul>
<li>直接光照</li>
</ul>
<p><img src="RayTracing/../assets/127.PNG" alt="" /></p>
<ul>
<li>直接光照 + 1次间接光照</li>
</ul>
<p><img src="RayTracing/../assets/128.PNG" alt="" /></p>
<blockquote>
<p>💡 为什么这么复杂的光照过程能被看上去这么简单的公式精确模拟？<br />
因为它是基于物理的简化，物理规律就是简洁且真实的。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="着色频率"><a class="header" href="#着色频率">着色频率</a></h1>
<p>BlinnPhong模型描述了单点如何着色。<br />
着色频度描述如果对所有点着色。即以什么样的策略对每个点运用BlinnPhong。或者说，是对哪些点应用Blinn Phong</p>
<p>对于同一个几何模型，不同的着色频率会产生不同的效果：</p>
<p><img src="Shading/../assets/36.PNG" alt="" /></p>
<p>以下是几种不同的着色频率（着色策略）：</p>
<h2 id="着色应用于平面flat-shading"><a class="header" href="#着色应用于平面flat-shading">着色应用于平面（Flat Shading）</a></h2>
<p>着色应用于一个平面上。一个平面只做一次shading，整个平面都用这个shading的结果。</p>
<img src="Shading/../assets/flatshading.jpg" width = 300 />
<h2 id="着色应用于顶点gouraud-shading"><a class="header" href="#着色应用于顶点gouraud-shading">着色应用于顶点（Gouraud Shading）</a></h2>
<p>着色应用三角形面片的顶点上，每个顶点先计算法向再计算着色，三角形内通过插值计算出着色</p>
<img src="Shading/../assets/gouraudshading.jpg" width = 300 />
<h2 id="着色应用于像素phong-shading"><a class="header" href="#着色应用于像素phong-shading">着色应用于像素（Phong Shading）</a></h2>
<p>着色应用于像素，每个像素都计算法向与着色</p>
<img src="Shading/../assets/phongshading.jpg" width = 300 />
<h1 id="比较"><a class="header" href="#比较">比较</a></h1>
<p>不同着色频率和着色几何体的效果比较：</p>
<div align="center"> <img src="Shading/../assets/shadingcompare.jpg" width = 600 /> </div>
<p>从上往下，几何形体本身越来越细腻光滑。</p>
<p>结论：</p>
<ol>
<li>当几何足够复杂时，可以使用相对简单的着色频率。</li>
<li>当几何简单时，Phong Shading计算量大。当几何足够复杂时，例如顶点数多于像素数时，Flat Shading的计算量更大。</li>
</ol>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="计算一个点的法向量"><a class="header" href="#计算一个点的法向量">计算一个点的法向量</a></h1>
<h2 id="方法一利用几何特征"><a class="header" href="#方法一利用几何特征">方法一：利用几何特征</a></h2>
<p>例如，已知object是个球体。可直接球出球表面某点的n（法向量）</p>
<img src="Shading/../assets/利用几何特征.jpg" width = 300 />
<h2 id="方法二利用三角形面片"><a class="header" href="#方法二利用三角形面片">方法二：利用三角形面片</a></h2>
<p>\[
N_v=\frac{\sum{N_i}}{||\sum{N_i}||}
\]</p>
<p>相邻的三角形的n的平均或加权平均</p>
<blockquote>
<p><strong>📌</strong> 一个点可做多个三角形的顶点，将这些三角形（面）的法向量求均值，可简单的看做是这个点的法向量</p>
</blockquote>
<p>如果考虑加权平均，则把三角形的面积做为权重。</p>
<img src="Shading/../assets/利用三角形.jpg" width = 300 />
<h1 id="计算一个像素的法线"><a class="header" href="#计算一个像素的法线">计算一个像素的法线</a></h1>
<p>先求出顶点的法线，再利用<strong>重心坐标</strong>做插值。</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>这一节处理渲染方程中Input Light相关的部分。</p>
<p><img src="Light/../assets/69-28-4.png" alt="" /></p>
<p>全局光照 = 直接光照 + 间接光照</p>
<p>要解决的问题：<br />
(1) 如何快速地获取来自各个方向的Input Light？<br />
(2) 如果预计算Input Light，数据量非常大，怎样高效地存储？<br />
(3) 如何让材质与Input Light做积分。</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-light-solution"><a class="header" href="#simple-light-solution">Simple Light Solution</a></h1>
<p>假设简单场景，只有一个主光源</p>
<h2 id="直接光照"><a class="header" href="#直接光照">直接光照</a></h2>
<p>由于直接一个光源，可以直接计算直接光照。<br />
可以直接入射光方向与物体表面法向方向决定是否表现是高光效果。</p>
<h2 id="间接光照"><a class="header" href="#间接光照">间接光照</a></h2>
<p>自定义一个常数环境光ambient</p>
<p><img src="Light/../assets/69-12-1.png" alt="" /></p>
<h3 id="常数环境光存在的问题"><a class="header" href="#常数环境光存在的问题">常数环境光存在的问题</a></h3>
<blockquote>
<p>ambient 可以做间接光照效果，但会使整个场景统一变亮。看上去会有平面感。</p>
</blockquote>
<p><img src="Light/../assets/69-28-3.png" alt="" /></p>
<h2 id="光在材质上的效果"><a class="header" href="#光在材质上的效果">光在材质上的效果</a></h2>
<h3 id="environment-map-reflection"><a class="header" href="#environment-map-reflection">Environment Map Reflection</a></h3>
<blockquote>
<p>增加物体反射光线的效果。</p>
</blockquote>
<p><img src="Light/../assets/69-13-1.png" alt="" /></p>
<p><strong>Early stage exploration of image- based lighting</strong></p>
<p>方法：六面体环境贴图 cudemap</p>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<blockquote>
<p>本质上，把一个半球形的光场模拟为均匀的环境光。环境光中高频内容用 envirnment map 表达。 </p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="background"><a class="header" href="#background">Background</a></h1>
<h2 id="why-global-illumination-is-important"><a class="header" href="#why-global-illumination-is-important">Why Global Illumination is Important</a></h2>
<p><img src="Light/../assets/69-28-3.png" alt="" /></p>
<blockquote>
<p>ambient 可以做间接光照效果，但会使整个场景统一变亮。看上去会有平面感。因此真实计算间接光照，而不是用一个简单的常数值。</p>
</blockquote>
<h2 id="why-pre-computed-global-illumination"><a class="header" href="#why-pre-computed-global-illumination">Why Pre-computed Global Illumination</a></h2>
<blockquote>
<p>假设场景中90%的东西是不动的，大量数据预计算，空间换时间。</p>
</blockquote>
<h2 id="预计算gi的关键问题"><a class="header" href="#预计算gi的关键问题">预计算GI的关键问题</a></h2>
<blockquote>
<p>预计算的GI，是对一个球面空间的采样。</p>
</blockquote>
<p>How to Represent Input Indirect Light</p>
<p>(1) GI的数据量非常大。<br />
使用几个<a href="https://caterpillarstudygroup.github.io/mathematics_basic_for_ML/Geometry/SphericalHarmonics.html">球谐基</a>系数，可以把球面的光照信号大致表达出来。<br />
由于 GI 只需要表达低频，使用到 1 阶就足够了。这样就用极少的数据表达出了一整张图像的大致样子。</p>
<p>(2) 如何让材质与GI做积分。<br />
频域上的一次卷积相当于对图像域上每个像素做加权平均</p>
<p>🔎<a href="Light/../Rasterization/TimeVsFrequency.html">傅利叶变换</a></p>
<h1 id="pipeline"><a class="header" href="#pipeline">Pipeline</a></h1>
<h2 id="sampling-irradiance-probe-anywhere"><a class="header" href="#sampling-irradiance-probe-anywhere">Sampling Irradiance Probe Anywhere</a></h2>
<blockquote>
<p>在任何一个点取 Irradiance Probe 信息，展开为下图</p>
</blockquote>
<p><img src="Light/../assets/69-34-1.png" alt="" /></p>
<h2 id="compress-irradiance-probe-to-sh1"><a class="header" href="#compress-irradiance-probe-to-sh1">Compress Irradiance Probe to SH1</a></h2>
<p><img src="Light/../assets/69-35.png" alt="" /></p>
<blockquote>
<p>用 1 阶球谐基(对应 4 个系数)压缩后还原得到图 2。<br />
图 2 足以表达光的明暗，且数据非常连续。<br />
通一个简单的线性运算，就可以从图中查询出任意一个方</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sh-lightmap-precomputed-gi"><a class="header" href="#sh-lightmap-precomputed-gi">SH Lightmap: Precomputed GI</a></h1>
<p><img src="Light/../assets/69-37-1.png" alt="" /></p>
<h2 id="parameterized-all-scene-into-huge-2d-lightmap-atlas"><a class="header" href="#parameterized-all-scene-into-huge-2d-lightmap-atlas">Parameterized all scene into huge 2D lightmap atlas</a></h2>
<p><img src="Light/../assets/69-38.png" alt="" /></p>
<p><strong>Lightmap density</strong></p>
<ul>
<li>Low-poly proxy geometry</li>
<li>Fewer UV charts/islands</li>
<li>Fewer lightmap texels are wasted</li>
</ul>
<h2 id="using-offline-lighting-farm-to-calculate-irradiance-probes-for-all-surface-points"><a class="header" href="#using-offline-lighting-farm-to-calculate-irradiance-probes-for-all-surface-points">Using offline lighting farm to calculate irradiance probes for all surface points</a></h2>
<p><strong>Indirect lighting, final geometry</strong></p>
<ul>
<li>Project lightmap from proxies to all LODs</li>
<li>Apply mesh details</li>
<li>Add short-range, high￾frequency lighting detail by HBAO</li>
</ul>
<h3 id="lightmap-lighting--direct-lighting"><a class="header" href="#lightmap-lighting--direct-lighting">Lightmap: Lighting + Direct Lighting</a></h3>
<p><strong>Direct + indirect lighting,final geometry</strong></p>
<ul>
<li>Compute direct lighting dynamically </li>
</ul>
<h2 id="compress-those-irradiance-probes-into-sh-coefficients"><a class="header" href="#compress-those-irradiance-probes-into-sh-coefficients">Compress those irradiance probes into SH coefficients</a></h2>
<h2 id="store-sh-coefficients-into-2d-atlas-lightmap-textures"><a class="header" href="#store-sh-coefficients-into-2d-atlas-lightmap-textures">Store SH coefficients into 2D atlas lightmap textures</a></h2>
<h2 id="final-shading-with-materials"><a class="header" href="#final-shading-with-materials">Final Shading with Materials</a></h2>
<p><strong>Final frame</strong></p>
<ul>
<li>Combined with materials</li>
</ul>
<h1 id="lightmap-总结"><a class="header" href="#lightmap-总结">Lightmap 总结</a></h1>
<ul>
<li><strong>Pros</strong>
<ul>
<li>Very efficient on runtime</li>
<li>Bake a lot of fine details of GI on environment</li>
</ul>
</li>
<li><strong>Cons</strong>
<ul>
<li>Long and expensive precomputation (lightmap farm)</li>
<li>Only can handle <strong>static scene and static light</strong></li>
<li>Storage cost on package and GPU</li>
</ul>
</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h3 id="light-probe"><a class="header" href="#light-probe">Light Probe</a></h3>
<p><img src="Light/../assets/69-43.png" alt="" /></p>
<h3 id="reflection-probe"><a class="header" href="#reflection-probe">Reflection Probe</a></h3>
<p><img src="Light/../assets/69-45.png" alt="" /></p>
<blockquote>
<p>Reflection Probe 的特点：<br />
(1) 数量少<br />
(2) 精度高，因为高光对高频很敏感。</p>
</blockquote>
<h3 id="light-probes--reflection-probes"><a class="header" href="#light-probes--reflection-probes">Light Probes + Reflection Probes</a></h3>
<ul>
<li>
<p><strong>Pros</strong></p>
<ul>
<li>Very efficient on runtime</li>
<li>Can be applied to both <strong>static and dynamic objects</strong></li>
<li>Handle both diffuse and specular shading</li>
</ul>
</li>
<li>
<p><strong>Cons</strong></p>
<ul>
<li>A bunch of SH light probes need some precomputation</li>
<li>Can not handle fine detail of GI. I.e, soft shadow on overlapped structures</li>
</ul>
</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="用纹理记录环境光照"><a class="header" href="#用纹理记录环境光照">用纹理记录环境光照</a></h1>
<p>以一个点出发，向其四周都能看到光，把这些光记录下来，就是环境光照。用纹理来描述环境光照，并环境光照渲染其他物体。</p>
<p>例如：这是某个点的环境光照</p>
<img src="Experience/../assets/environment1.jpg" width = 400 />
<p>用这个环境光照来渲染茶壶，就得到了这样的效果</p>
<img src="Experience/../assets/environment2.jpg" width = 400 />
<p>用纹理记录环境光照时，对光做了一些假设和简化：</p>
<ul>
<li>假设环境光的光源无限远，只记录某个方向上的光的信息（强度、颜色等），不记录光源的深度。</li>
<li>在记录光照信息时，不区分光照的种类。</li>
</ul>
<blockquote>
<p>❓ 光源的深度信息对效果有什么影响？</p>
</blockquote>
<h2 id="spherical-环境图"><a class="header" href="#spherical-环境图">Spherical 环境图：</a></h2>
<p>如果对一个点的周围均匀采样，得到的是一个球。因此，记录环境光照的纹理图是一个球面的图（左）。</p>
<img src="Experience/../assets/environment3.jpg" width = 600 />
<p>但把球面的环境光照纹理图展开，会出现扭曲：</p>
<img src="Experience/../assets/environment4.jpg" width = 600 />
<blockquote>
<p>❓ 展开后扭曲会有什么影响？渲染正常不就行了？</p>
</blockquote>
<h2 id="cube-map"><a class="header" href="#cube-map">Cube Map</a></h2>
<p>球表面点和立方体表面点可以一一对应。只要计算出这种对应关系，就能把球面上的光照信息存储到立方体表面。</p>
<p><img src="Experience/../assets/cubemap.jpg" alt="" /></p>
<p>Cube Map展开后不会扭曲</p>
<p><img src="Experience/../assets/cubemap2.jpg" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2d纹理应用"><a class="header" href="#2d纹理应用">2D纹理应用</a></h1>
<p>纹理，原义为贴图。广义上，纹理=内存 + 范围查询（滤波）。通过这样的技术，可以得到很多实用的功能。</p>
<h2 id="凹凸贴图---用复杂纹理代替复杂几何"><a class="header" href="#凹凸贴图---用复杂纹理代替复杂几何">凹凸贴图 - 用复杂纹理代替复杂几何</a></h2>
<h3 id="凹凸贴图---用纹理记录顶点的高度偏移"><a class="header" href="#凹凸贴图---用纹理记录顶点的高度偏移">凹凸贴图 - 用纹理记录顶点的高度偏移</a></h3>
<h4 id="原理-7"><a class="header" href="#原理-7">原理</a></h4>
<p>用纹理定义某个点的相对高度，在物体几何信息不变的条件下，得到视觉上的表面凹凸效果，即：用复杂纹理代替复杂几何</p>
<p>原理：影响高度--&gt;影响法线--&gt;影响着色</p>
<h4 id="bump-mapping"><a class="header" href="#bump-mapping">Bump Mapping</a></h4>
<p>效果：</p>
<img src="Texture/../assets/bump1.jpg" width = 600 />
<h4 id="具体步骤-3"><a class="header" href="#具体步骤-3">具体步骤</a></h4>
<ul>
<li>以2D为例</li>
</ul>
<img src="Texture/../assets/bump.jpg" width = 600 />
<p>黑色为原始几何信息。桔色为叠加高度偏移之后的几何信息。由于高度变化带了法线的变化，p点的法线变成了n。如何计算新的方向n？</p>
<img src="Texture/../assets/bump2.jpg" width = 600 />
<ol>
<li>在p点定义局部坐标系，令原始法线方向向上，为(0,1)或(0,0,1)</li>
<li>想要让p表现出在p'处的效果，需要计算出在局部坐标系下，p'处的切线方向和法线方向<br />
假设p点沿当前方向向右移动了距离dx，那么它会向上移动dy。切线方向就是(dx, dy)。为了简化计算，令dx=1，只需要求出此时的dy（也就是dp）即可。</li>
</ol>
<p>$$
dp = c \cdot [h(p+1) - h(p)]
$$</p>
<p>c是一个超参，用于控制高度位移的影响大小。</p>
<ol start="3">
<li>根据dp（通过纹理记录的值），直接使用dp就可以得出p'处的切线方向和法线方向</li>
</ol>
<blockquote>
<p>✅ 如果dp是通过高度偏移算出来的，则称为凹凸贴图。如果dp是直接从纹理中查出来的，则称为法线贴图。</p>
</blockquote>
<p>切线方向是(1, dp)，对应的法线方向是(-dp, 1)。</p>
<ol start="4">
<li>
<p>第一步中把世界坐标系转成了局部坐标系，以保证原始的法线方向是向上的，便于计算。现在要把局部坐标系的法线方向转回到世界坐标系中。</p>
</li>
<li>
<p>根据新的法线做shading</p>
</li>
</ol>
<ul>
<li>3D</li>
</ul>
<p>$$
dp/du = c1 \cdot [h(u+1) - h(u)]  \\
dp/dv = c1 \cdot [h(v+1) - h(v)]
$$</p>
<table><thead><tr><th></th><th>2D</th><th>3D</th></tr></thead><tbody>
<tr><td>p的法线方向</td><td>(0,1)</td><td>(0,0,1)</td></tr>
<tr><td>p'的切线方向</td><td>(1,dp)</td><td>(1, dp/du, dp/dv)</td></tr>
<tr><td>p'的法线方向</td><td>(-dp, 1)</td><td>(-dp/du, -dp/dv, 1)</td></tr>
</tbody></table>
<blockquote>
<p>❗ 方向算出来之后需要归一化。 </p>
</blockquote>
<h3 id="法线贴图---用纹理记录顶点的法线"><a class="header" href="#法线贴图---用纹理记录顶点的法线">法线贴图 - 用纹理记录顶点的法线</a></h3>
<p>与凹凸帖图类似，也是为了达到以假乱真的效果。</p>
<blockquote>
<p>💡 只是存储的计算结点不同，但都是假的</p>
</blockquote>
<h2 id="位移贴图---用纹理记录顶点的高度偏移"><a class="header" href="#位移贴图---用纹理记录顶点的高度偏移">位移贴图 - 用纹理记录顶点的高度偏移</a></h2>
<p>位移贴图和凹凸贴图所记录的信息是一样的。<br />
区别是，位移贴图会真的移动几何的顶点位置。</p>
<ul>
<li>位移贴图的优点：</li>
</ul>
<p><img src="Texture/../assets/displacement.jpg" alt="" /></p>
<p>凹凸贴图只是一种视觉的上欺骗，它会在两个地方露馅：</p>
<ol>
<li>边缘是圆的，没有凹凸感</li>
<li>缺少“自己阴影投影到自己身上”<br />
位移贴图能真实地改变顶点，不会出现以上的问题</li>
</ol>
<blockquote>
<p>💡 就好像基于经验公式的渲染一定不如基于物理意义的渲染来的真实。假的总有模仿不了的，这会成为它的局限性，但它能简化问题。</p>
</blockquote>
<ul>
<li>位移贴图的局限性：</li>
</ul>
<p>位移贴图要求模型的三角形足够细。因为它只能改变顶点位置。如果三角形比较大，三角形内部的位置就不能改变。<br />
从采样原理解释就是，模型表面的采样频率应该能跟上纹理变化的频率。</p>
<ul>
<li>改进：动态三角形细分</li>
</ul>
<p>这是应用在direct X里面的一套方法。<br />
先使用比较粗的模型，在应用纹理的过程中检测并动态地决定是否需要对三角形做细分。</p>
<h2 id="用纹理记录之前算好的信息"><a class="header" href="#用纹理记录之前算好的信息">用纹理记录之前算好的信息</a></h2>
<p>例如着色、阴影等信息，是可以提前算好，写到纹理图中，然后再应用纹理。</p>
<p><img src="Texture/../assets/48.PNG" alt="" /></p>
<p>例如上图中，中间图存储了原图的环境光遮蔽信息。这是一个[0,1]的信息，用于表达原图对应位置是否由于被其它部位遮蔽而呈现出较深的颜色。<br />
应用是把着色结果与这个遮蔽信息相乘。</p>
<blockquote>
<p>💡 提前准备是空间换时间的通俗表达。提前准备好仍免不了计算，只是把计算提前了，该做的仍然要做。<br />
提前准备好也有可能会有实际上用不到的风险，那么这一部分提前计算会被浪费。提前计算消耗的是廉价的时间和空间，一但用上了，省去的是昂贵的运行时计算的时间，因此是高回报的投资。</p>
</blockquote>
<h2 id="parallax-and-displacement-mapping"><a class="header" href="#parallax-and-displacement-mapping">Parallax and Displacement Mapping</a></h2>
<p><img src="Texture/../assets/06-19-1.png" alt="" /></p>
<p><img src="Texture/../assets/06-19-2.png" alt="" /></p>
<p>Parallax Mapping: Due to the height of the surface, the eye sees point B instead of point A. It creates a sense of dimensionality</p>
<blockquote>
<p>视差贴图。</p>
</blockquote>
<blockquote>
<p>凹凸帧图能产生明暗分明的效果。但仍然会有平面感，因为眼睛看到的点和应该看到的点，有视差。常用做法，ray marching(Parallax mapping)<br />
缺点：(1) 几步测一下，比较贵<br />
(2) 只是产生视觉上的凹凸感，边界上还能看出 artifacts (光滑)<br />
Displacement mapping 真实修改地形</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="材质与外观"><a class="header" href="#材质与外观">材质与外观</a></h1>
<p>外观是材质和光线作用的结果。因此本章要学的是<strong>不同材质和光线相互作用的方式</strong>。</p>
<p>材质是渲染方程中的 BRDF 项</p>
<h1 id="brdf的性质"><a class="header" href="#brdf的性质">BRDF的性质</a></h1>
<ul>
<li>非负性</li>
</ul>
<p>$$
f_r(\omega_i\rightarrow \omega_r) \ge 0
$$</p>
<ul>
<li>线性</li>
</ul>
<p>可以把BRDF拆成很多块分别做path tracing再加起来，得到的结果与整个BRDF做path tracing的结果相同。</p>
<blockquote>
<p>❓ 拆成多块是什么意思？BRDF不是概率密度函数吗？为什么可以直接相加？不是对入射光做叠加吗？</p>
</blockquote>
<ul>
<li>可逆性</li>
</ul>
<p>$$
f_r(\omega_i\rightarrow \omega_r) = f_r(\omega_r\rightarrow \omega_i)
$$</p>
<ul>
<li>能量守恒</li>
</ul>
<p>出射能量一定不多于入射能量。</p>
<ul>
<li>各向同性：</li>
</ul>
<p>$$
fr(\theta_i, \phi_i;\theta_r, \phi_r) = fr(\theta_i, \phi_i, \phi_r - \phi_i)
$$</p>
<p>其中\(\theta_r\), \(\phi_r\)为方位角</p>
<h1 id="brdf的测量"><a class="header" href="#brdf的测量">BRDF的测量</a></h1>
<p>好像跟算法没关系，不记了。</p>
<blockquote>
<p>✅ 实际上BRDF的获取也是图形学的重要内容。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blinn-phong-反射模型"><a class="header" href="#blinn-phong-反射模型">Blinn-Phong 反射模型</a></h1>
<p>这是一个简单基础的模型，属于经验模型，并不完全符合物理。<br />
它利用光的可叠加属性，将光分成了三种成分，分别针对这三种成分的光，模拟光源对物体（光与材质的积分结果）的作用。</p>
<p><img src="Shading/../assets/reflection.jpg" alt="" /></p>
<ul>
<li>高光(Specular highlights): 光线反射到镜面反射附近</li>
<li>漫反射(Diffuse reflection): 光线被反射到各个方向上</li>
<li>环境光(Ambient lighting): 假设任何一个点会接收到来自环境的常­量的光</li>
</ul>
<blockquote>
<p>💡 问题简化抽象，可以快速得到近似的结果。<br />
就像五行八卦就是对现实世界的抽象。<br />
优点是：简化理解。<br />
缺点是：不一定完全符合真实，用应用的局限性</p>
</blockquote>
<p>$$
\begin{align*}
L_0 &amp;=\int (f_{BRDF}\cdot L_i)dw  \\
&amp; =\int (f_{BRDF}\cdot (L_a+L_d+L_s))dw  \\
&amp;=\int (f_{BRDF}\cdot L_a)dw+\int (f_{BRDF}\cdot L_d)dw+\int (f_{BRDF}\cdot L_s)dw   \\
&amp;=k_a+k_d+k_s 
\end{align*}
$$</p>
<h1 id="定义-1"><a class="header" href="#定义-1">定义</a></h1>
<div align="center"> <img src="Shading/../assets/shadingpoint.jpg" width = 290 /> </div>
<ul>
<li>shading point：当前要计算着色的点，位于物体表面。物体在shading point处的属性包含color, shinness。</li>
<li>（\(\hat{n}\)）Surface normal：假设点附近极小范围内是一个平面，n为平面指向外的法向量</li>
<li>（\(\hat{v}\)）Viewer direction：观测方向</li>
<li>（\(\hat{l}\)）Light direction：光源方向，与光照向point的方向相反</li>
</ul>
<blockquote>
<p><strong>📌</strong> \(\hat{l}\)如何计算？</p>
<p>光源的位置减去shading point的位置，得到向量，然后求出单位长度\(\hat{l}\)</p>
</blockquote>
<h1 id="三种成分"><a class="header" href="#三种成分">三种成分</a></h1>
<h2 id="漫反射"><a class="header" href="#漫反射">漫反射</a></h2>
<h3 id="漫反射的特点"><a class="header" href="#漫反射的特点">漫反射的特点</a></h3>
<ol>
<li>打到 point 上的光线被均匀地反射出去（与观测点v没有关系）</li>
</ol>
<div align="center"> <img src="Shading/../assets/diffuse.jpg" width = 290 /> </div>
<ol start="2">
<li>l 与 n 的夹角决定了 point 接收到的光线的强度(Lambert's cosine law)</li>
</ol>
<p><img src="Shading/../assets/lambert.jpg" alt="" /></p>
<blockquote>
<p>👆 假设光线是离散的，可以看出，当表面倾斜时，它接收到的光线会变少。理解为接收到的光线的强度变少。</p>
</blockquote>
<ol start="3">
<li>圆心是点光源，向外辐射能量。根据能量守恒定理（不考虑传播损耗），每个圆上的能量之和不变，因此某点处的能量与它到光源的距离平方是反比。</li>
</ol>
<div align="center"> <img src="Shading/../assets/lightfalloff.jpg" width = 400 /> </div>
<blockquote>
<p>✅如果考虑三维空间，则应该是距离的立方。</p>
</blockquote>
<h3 id="漫反射项公式"><a class="header" href="#漫反射项公式">漫反射项公式</a></h3>
<p>通过以上分析，定义漫反射的能量公式为：</p>
<p>\[
L_d=k_d\left( I/r^2 \right) \max \left( 0,\boldsymbol{n}\cdot \boldsymbol{l} \right) 
\]</p>
<ul>
<li>\(L_d\)： shading point接收到的漫反射能量</li>
<li>\(k_d\)： shading point对光的吸收率 (例如，不同的颜色对光的吸收能力不同)</li>
<li>\(\left( I/r^2 \right)\)： 有多少能量到达了point</li>
<li>\(\max \left( 0,\boldsymbol{n}\cdot \boldsymbol{l} \right) \)： 从正面照射的光，漫反射才有意义 （非正面射入，\(\boldsymbol{n}\cdot \boldsymbol{l}\)的值小于零）</li>
<li>\(\boldsymbol{n}\cdot \boldsymbol{l}\)： 表示有多少能量被point接收</li>
<li>漫反射与观察者方向无关，因此公式中没有v的体现。</li>
</ul>
<h3 id="漫反射项的效果"><a class="header" href="#漫反射项的效果">漫反射项的效果</a></h3>
<p><img src="Shading/../assets/diffuseappearance.jpg" alt="" /></p>
<h2 id="高光项"><a class="header" href="#高光项">高光项</a></h2>
<h3 id="高光的特点"><a class="header" href="#高光的特点">高光的特点</a></h3>
<div align="center"> <img src="Shading/../assets/highlight.jpg" width = 600 /> </div>
<p>R 为物体镜面反射的方向，当 v 和 R 接近时，会看到高光。</p>
<p>\(h=\frac{v+l}{||v+l||}\) 代表了 v+l 的方向， h 称为半程向量 half vector。 当v和R接近时，v+l 的方向(h)与n接近:</p>
<blockquote>
<p><strong>💡</strong> 为什么用\(n\cdot h\)代替\(v\cdot R\)？</p>
<p>因为\(n\cdot h\)更容易计算</p>
</blockquote>
<h3 id="高光项的公式"><a class="header" href="#高光项的公式">高光项的公式</a></h3>
<p>通过以上分析，定义高光项的能量公式为：</p>
<p>\[
L_s=k_s\left( I/r^2 \right) \max \left( 0, \cos \alpha \right) =k_s\left( I/r^2 \right) \max \left( 0, n\cdot h \right) ^p
\]</p>
<ul>
<li>\(k_s\) 吸收率，通常认为高光是白色，也就是全吸收</li>
<li>\(\left( I/r^2 \right)\) 表示有多少能量到达了point</li>
<li>\(\max \left( 0, n\cdot l \right) ^p\) 表示n和h的接近程度</li>
<li>\(L_s\) 同样应该考虑有多少能量被接收，但Blinn Phong模型将这个因素简化了</li>
</ul>
<blockquote>
<p><strong>💡</strong> 公式中为什么会有指数p？</p>
<p>在保证函数趋势不变的同时，让高光更集中，通常取[100, 200]</p>
<img src="Shading/../assets/p.jpg" width = 400 />
</blockquote>
<h3 id="高光项的效果"><a class="header" href="#高光项的效果">高光项的效果</a></h3>
<img src="Shading/../assets/speculate.jpg" width = 600 />   
<blockquote>
<p>👆 漫反射项 + 高光项</p>
</blockquote>
<p>Ks变大，高光变亮。p变大，高光范围变小。</p>
<h2 id="环境光照项"><a class="header" href="#环境光照项">环境光照项</a></h2>
<p>Blinn Phong模型假设所有 point 接收到来自环境光的强度相同，且为常数:</p>
<p>\[
L_a=k_aI_a
\]</p>
<p>与\(l\)和\(v\)无关</p>
<h1 id="模型总述"><a class="header" href="#模型总述">模型总述</a></h1>
<p><img src="Shading/../assets/69-15-1.png" alt="" /></p>
<blockquote>
<p><strong>💡</strong> 为什么不考虑point到v的距离对能量的影响？？</p>
<p>这部分比较复杂,Blinn-phong模型没有考虑这个问题</p>
</blockquote>
<blockquote>
<p>💡 解决复杂问题的几个方法：</p>
<ol>
<li>把问题分解为子问题，降低复杂度</li>
<li>把问题从应用场景、难点等角度划分，每一部分针对其特点解决</li>
<li>问题近似、简化</li>
</ol>
</blockquote>
<h1 id="problem-of-blinn-phong"><a class="header" href="#problem-of-blinn-phong">Problem of Blinn-Phong</a></h1>
<ul>
<li>Not energy conservative Unstable in ray-tracing</li>
</ul>
<p><img src="Shading/../assets/69-16-1.png" alt="" /></p>
<ul>
<li>Hard to model complex realistic material</li>
</ul>
<p><img src="Shading/../assets/69-16-2.png" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="漫反射材质"><a class="header" href="#漫反射材质">漫反射材质</a></h1>
<p>漫反射是指：任何方向的光线进来，都会被均匀地反射到各个方向去。</p>
<p>假设：入射光是 Uniform 的，出射光是漫反射，也是 uniform 的，那么BRDF项为fr = c（c 的数值与颜色有关）</p>
<p>$$
L_o(\omega_o) = \int L_i f_r \cos\theta_i d\omega_i
$$</p>
<p>这种情况下，Li*fr这一部分是常数，可以提取到wi外面，得：</p>
<p>$$
L_o(\omega_o) = L_i f_r \int_{H^2}\cos\theta_i d\omega_i = \pi f_r L_i
$$</p>
<p>化简得：</p>
<p>$$
fr = \frac{1}{\pi} (\frac{L_o}{L_i})
$$</p>
<p>假设材质不吸收任何能量，根据能量守恒，\(L_i = L_o\)，则：</p>
<p>$$
fr = \frac{1}{\pi}
$$</p>
<p>但如果材质会吸收任何能量，则：</p>
<p>$$
\rho = \frac{L_o}{L_i} \lt 1
$$</p>
<p>\(\rho\)称为散射率albedo，范围[0，1]，数值与颜色有关。</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossy材质"><a class="header" href="#glossy材质">Glossy材质</a></h1>
<p>类似镜面反射的材质。例如铜镜、抛光的金属。</p>
<p><img src="Material/../assets/147.PNG" alt="" /></p>
<blockquote>
<p>✅ 类似后面的微表面材质。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="玻璃水"><a class="header" href="#玻璃水">玻璃、水</a></h1>
<p><img src="Material/../assets/148.PNG" alt="" /></p>
<p>折射 + 反射，例如玻璃和水</p>
<h2 id="反射-1"><a class="header" href="#反射-1">反射</a></h2>
<p>入射角 = 出射角</p>
<h3 id="理解1"><a class="header" href="#理解1">理解1</a></h3>
<p><img src="Material/../assets/149.PNG" alt="" /></p>
<p>$$
\omega_i + \omega_o = 2(\omega_i \cdot n ) n
$$</p>
<p>根据平行四形法则，wi+wo的结果与n同方向，且大小为\(\omega_i\cos\theta_i\)的两倍</p>
<h3 id="理解2"><a class="header" href="#理解2">理解2</a></h3>
<p>把wi和wo都看作是空间中的方向，因此可以分解为\(\theta\)和\(\phi\)。出射角和入射角，他们的\(\theta\)相同，\(\phi\)相差了\(\pi\)。</p>
<blockquote>
<p>✅ 在以反射平面为xz平面的局部坐标系下</p>
</blockquote>
<h2 id="折射"><a class="header" href="#折射">折射</a></h2>
<p>折射定率：</p>
<p><img src="Material/../assets/150.PNG" alt="" /></p>
<p>$$
\eta_i \sin \theta_i = \eta_t \sin \theta_t
$$</p>
<p>说明：<br />
\(\eta_i\)：不同材质有不同折射率。<br />
\(\theta_i\)：入射角<br />
\(\theta_t\)：出射角</p>
<p>当入射材质折射率&gt;出射材质折射率，有可能折射变为全反射</p>
<p>BSDF(散射) = BRDF(反射) + BTDF(折射)</p>
<h2 id="菲涅耳项"><a class="header" href="#菲涅耳项">菲涅耳项</a></h2>
<p>反射和折射同时发生时，分别各多少<br />
答：与入射角有关。
<img src="Material/../assets/151.PNG" alt="" />
如图中，从不同的角度看过去，书的反射的影子强度不同。<br />
计算公式，太复杂，用的时候直接查就好了。</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="微表面模型-micro-facet-material"><a class="header" href="#微表面模型-micro-facet-material">微表面模型 Micro facet Material</a></h1>
<p>当物体很远很小时，从远处看， 是平面且粗糙的。从近处看，是几何且<strong>镜面反射</strong>。</p>
<p>从微观上看，每个几何表面都有各自的法线方向。但拉远后，这些法线方向就抽象成了<strong>法线方向的分布</strong>。</p>
<blockquote>
<p>💡 本身是随机的，适用统计分布。本身是规律的，可以用公式计算规律。也有可能同一件事，从不同角度去看，会得到随机和有规律两种不同的结论。分析出的规律，也有可能最终还是以统计的方式体现。</p>
</blockquote>
<p>微表面的粗糙成度可以用法线分布来表示：</p>
<ul>
<li>当微表面的法线方向比较集中，材质就类似于glossy</li>
</ul>
<p><img src="Material/../assets/152.PNG" alt="" /></p>
<ul>
<li>当微表面的法线方向比较分散，材质就类似于diffuse</li>
</ul>
<p><img src="Material/../assets/153.PNG" alt="" /></p>
<h2 id="brdf-model-based-on-microfacet"><a class="header" href="#brdf-model-based-on-microfacet">BRDF Model Based on Microfacet</a></h2>
<p><img src="Material/../assets/69-49-1.png" alt="" /></p>
<p>$$
L_o(x,\omega _o)=\int _{H^2}\begin{pmatrix}<br />
k_d\frac{c}{\pi } +\frac{DFG}{4(\omega _o\cdot n)(\omega _i\cdot n)}
\end{pmatrix} L_i(x,\omega _i)(\omega _i\cdot n)dw_i
$$</p>
<blockquote>
<p>diffuse：漫反射与 Bling Phong 类似，简化成常数。specular：高光，比 Bling Phong 要复杂，其中 D 项与之类似。<br />
DFG 中每个字母代表一种光学现象。</p>
</blockquote>
<blockquote>
<p>💡 用物理方法模拟的难点在于如何基于物理去建模。用简体近似的方法模拟，难点在于应对简化不合理地方出现的失真。用数据模拟，难点在于大量高质量的数据。<br />
光追属于第一种，这里的方法属于第二种，机器学习属于第三种。</p>
</blockquote>
<h2 id="normal-distribution-function-法向分布方程"><a class="header" href="#normal-distribution-function-法向分布方程">Normal Distribution Function 法向分布方程</a></h2>
<p><img src="Material/../assets/69-50-1.png" alt="" /></p>
<p><img src="Material/../assets/69-50-2.png" alt="" /></p>
<blockquote>
<p>\(\alpha \) 代表 roughness，范围取 [0，1]</p>
</blockquote>
<p><img src="Material/../assets/69-50-3.png" alt="" /></p>
<blockquote>
<p>GGX 曲线的特点：高频更具表现力，低频不会那么快消失。</p>
</blockquote>
<h2 id="geometric-attenuation-term-self-shadowing由于表面不平导致的自遮挡"><a class="header" href="#geometric-attenuation-term-self-shadowing由于表面不平导致的自遮挡">Geometric Attenuation Term (self-shadowing)由于表面不平导致的自遮挡</a></h2>
<p><img src="Material/../assets/69-51-3.png" alt="" /></p>
<blockquote>
<p>遮挡影响的特点：<br />
(1) 遮挡可能发生在入射光射向物体表面，也发生在反射光射向眼睛，因此要算两遍。<br />
(2) 与是入射光还是反射光无关<br />
(3) 与入／反射光与法线的夹角有关<br />
(4) 与 D 方式中的 (\( \alpha \)) 有关</p>
</blockquote>
<p><img src="Material/../assets/69-51-2.png" alt="" /></p>
<h2 id="fresnel-equation"><a class="header" href="#fresnel-equation">Fresnel Equation</a></h2>
<p><img src="Material/../assets/69-52-2.png" alt="" /></p>
<blockquote>
<p>当视线与物体表面的切平面夹角很小时，反射系数会急巨增加，看到倒影效果。<br />
参数：\(\alpha \)，fresnel 系数</p>
</blockquote>
<p><img src="Material/../assets/69-52-3.png" alt="" /></p>
<h1 id="physical-measured-material"><a class="header" href="#physical-measured-material">Physical Measured Material</a></h1>
<p><img src="Material/../assets/69-53-1.png" alt="" /></p>
<p><img src="Material/../assets/69-53-2.png" alt="" /></p>
<blockquote>
<p>一个关于真实材质的各项系数的数据集。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="各项同性各项异性材质"><a class="header" href="#各项同性各项异性材质">各项同性/各项异性材质</a></h1>
<p>各项同性，即物体微表面不存在一定的方向性，反之则是各项异性。各项异性材质一般是人为制造的材质。</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>光线追踪与光栅化是两种不同的呈像方式，但光栅化具有“can't handle global effect well”的局限性，不能呈现出以下的效果：</p>
<blockquote>
<p>✅ 一个像素上所呈现的效果，只与像素附近的几何信息有关，例如position, normal，只是在遮挡的时候考虑了global</p>
</blockquote>
<p><img src="RayTracing/../assets/83.PNG" alt="" /></p>
<ul>
<li>软阴影</li>
</ul>
<blockquote>
<p>✅ 考虑来自不同方向的光源</p>
</blockquote>
<ul>
<li>glossy反射。glossy是指像有点粗糙的镜子，或打模非常光滑的金属的一种材质</li>
</ul>
<blockquote>
<p>✅ 考虑邻居像素的normal</p>
</blockquote>
<ul>
<li>间接光照，即光线弹射不止一次</li>
</ul>
<blockquote>
<p>✅ 考虑与其它物理的交互</p>
</blockquote>
<p>因此有了光线追踪技术。</p>
<p>光栅化速度快，质量差， 能达到real-time。光线追踪速度慢，质量好，通常用于offline。</p>
<h1 id="光线追踪最基本的假设"><a class="header" href="#光线追踪最基本的假设">光线追踪最基本的假设</a></h1>
<ol>
<li>光线沿直线传播</li>
<li>光线可以交叉但不发生碰撞</li>
<li>光线从光源出发，经过不断弹射，打入眼中。</li>
<li>光路可逆。可以理解为从眼睛出发，追踪光路直到光源。</li>
</ol>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ray-casting-算法"><a class="header" href="#ray-casting-算法">Ray Casting 算法</a></h1>
<p>Ray Casting目标是找到从眼睛到光源之间的光路。</p>
<h2 id="假设"><a class="header" href="#假设">假设</a></h2>
<ol>
<li>光源是点光源。</li>
<li>camera 是一个点</li>
<li>完美折射（不考虑反射）</li>
<li>只弹射一次</li>
</ol>
<blockquote>
<p>✅ 仍只考虑local信息，解决不了前面的问题 </p>
</blockquote>
<h2 id="具体步骤-4"><a class="header" href="#具体步骤-4">具体步骤</a></h2>
<p><img src="RayTracing/../assets/84.PNG" alt="" /></p>
<ol>
<li>从眼睛向每个像素投出一根视线(eye ray)</li>
<li>光线和场景相交，求最近的交点</li>
<li>交点与光源连线，判断定是否在阴影中 </li>
<li>算着色 </li>
<li>写回像素值</li>
</ol>
<blockquote>
<p>💡 这个算法和前面的光栅化没有 本质区别。只是遍历眼睛出发的光和遍历物体收到的光的区别。前者只计算用于渲染的部分，而不是计算全部，减少计算量。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="whitted-风格算法递归"><a class="header" href="#whitted-风格算法递归">Whitted-风格算法(递归)</a></h1>
<h2 id="假设-1"><a class="header" href="#假设-1">假设</a></h2>
<ol>
<li>光源是点光源。</li>
<li>camera 是一个点</li>
<li>折射 + 反射</li>
<li>可以无限次弹射</li>
</ol>
<h2 id="具体步骤-5"><a class="header" href="#具体步骤-5">具体步骤</a></h2>
<p><img src="RayTracing/../assets/85.PNG" alt="" /></p>
<ol>
<li>从眼睛向每个像素投出一根视线(eye ray)</li>
<li>光线和场景相交，求最近的交点</li>
<li>光线在交点与可以发现反射和折射，反射和折射又新形成新的交点。反射能量 + 折射能量 &lt;= 1</li>
<li>所有的交点都称为弹射点。弹射点与光源连线，判断定是否在阴影中 </li>
<li>所有弹射点的着色求和</li>
<li>写回像素值</li>
</ol>
<h2 id="一些名词"><a class="header" href="#一些名词">一些名词</a></h2>
<ul>
<li>primary ray：眼睛打出的光线</li>
<li>secondary ray： 经过弹射的光线</li>
<li>shadow ray：物体与光源的连线</li>
</ul>
<h2 id="效果-6"><a class="header" href="#效果-6">效果</a></h2>
<p><img src="RayTracing/../assets/86.PNG" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ray-surface-交点"><a class="header" href="#ray-surface-交点">Ray-Surface 交点</a></h1>
<h2 id="定义-2"><a class="header" href="#定义-2">定义</a></h2>
<p>光线是一根射线，包含起点和方向，用(o, t)表示，即（起点，方向）</p>
<p><img src="RayTracing/../assets/87.PNG" alt="" /></p>
<p>ray equation：</p>
<p>$$
r(t) = o+td, 0\le t &lt; \infty
$$</p>
<h2 id="光线与球的交点"><a class="header" href="#光线与球的交点">光线与球的交点</a></h2>
<p>ray: \(R(t) = o + td\)<br />
圆: \((p - c) ^ 2 - R^2 = 0\)<br />
⇒ \((o + td - c) ^ 2 - R^2 = 0\)</p>
<p><img src="RayTracing/../assets/88.PNG" alt="" /></p>
<p>解出t，根据物理意义可知，t应满足：（1）t是实数，（2）t&gt;0，（3）如果有两个解，取较小的那个</p>
<h2 id="光线与任意隐式曲面的交点"><a class="header" href="#光线与任意隐式曲面的交点">光线与任意隐式曲面的交点</a></h2>
<p>ray: \(R(t) = o + td\)<br />
曲面： f(p) = 0</p>
<p>⇒ f(o + td)=0
解出t</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="光线与三角形的交点"><a class="header" href="#光线与三角形的交点">光线与三角形的交点</a></h1>
<p><img src="RayTracing/../assets/89.PNG" alt="" /></p>
<p>任意一个光线与封闭 mesh 求交，交点个数为奇数则起点在内，交点个数为偶数则起点在外</p>
<blockquote>
<p>✅ 事实上很多物体是半封闭的mesh，此时这个结论不一定适用。</p>
</blockquote>
<p>因此问题转化为光线与mesh上的三角形面片求交点</p>
<h2 id="常规方法"><a class="header" href="#常规方法">常规方法</a></h2>
<h3 id="第一步光线与三角形面片所在的平面求交点"><a class="header" href="#第一步光线与三角形面片所在的平面求交点">第一步：光线与三角形面片所在的平面求交点</a></h3>
<p>ray: \(R(t) = o + td\)</p>
<p><img src="RayTracing/../assets/90.PNG" alt="" /><br />
平面：\((p-p') \dot N = 0\)<br />
平面公式解释：点乘为0代表垂直，N是平面的法向量，p'为平面上任意一点。平面上的点应满足：它与p'的连线与N垂直。</p>
<p>⇒ \((o + td - p') \dot N = 0\)</p>
<p>解得：\(t = \frac{(p'- o) \dot N}{d \dot N}\)<br />
取t&gt;0的解</p>
<h3 id="第二步判断交点是否在三角形内"><a class="header" href="#第二步判断交点是否在三角形内">第二步：判断交点是否在三角形内</a></h3>
<p><a href="RayTracing/../Dependency/Vector.html">link</a></p>
<h2 id="加速方法mt"><a class="header" href="#加速方法mt">加速方法（MT）</a></h2>
<p>此方法可以<strong>同时求出光线与三角形所在平面的交点且立刻判断点是否在三角形内</strong>。</p>
<p>假设光线与三角形所在平面交点为p，用三角形的重心坐标来表达p为：</p>
<p>$$
p = (1-b_1 - b_2)P_0 + b_1P_1 + b_2P_2
$$</p>
<blockquote>
<p>🔎 <a href="RayTracing/../Texture/BarycentricCoordinates.html">三角形的重心坐标</a></p>
</blockquote>
<p>同时p也在光线(O+td)上，因此</p>
<p>$$
O + t D = (1-b_1 - b_2)P_0 + b_1P_1 + b_2P_2
$$</p>
<p>其中大写为3D已知向量，小写为未知标量</p>
<p>通过克莱默法则，可解得：
<img src="RayTracing/../assets/16.PNG" alt="" /></p>
<p>判定结果AC的条件：t&gt;0, b1&gt;0, b2&gt;0, 1-b1-b2&gt;0</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="光线与显式曲面求交"><a class="header" href="#光线与显式曲面求交">光线与显式曲面求交</a></h1>
<p>最常见的显式曲面是Mesh。</p>
<h2 id="基本方法"><a class="header" href="#基本方法">基本方法</a></h2>
<p>依次判断与曲面上的每个三角形求交。</p>
<p>速度非常慢！！！</p>
<p>因此需要使用一些方法来加速。</p>
<h2 id="bounding-volumes-包围盒"><a class="header" href="#bounding-volumes-包围盒">Bounding Volumes 包围盒</a></h2>
<p>一种可以把物体包围起来的简单几何形状。可用于简体计算。</p>
<p><img src="RayTracing/../assets/91.PNG" alt="" /></p>
<p>先判断光线与BV是否相交，然后再求与物体的相交情况。</p>
<p>最常见的BV是长方体。长方体可以看作是3个不同的对面（slab）形成的交集。</p>
<p><img src="RayTracing/../assets/92.PNG" alt="" /><img src="RayTracing/../assets/93.PNG" alt="" /><img src="RayTracing/../assets/94.PNG" alt="" /></p>
<p>因此又被称为AABB。AABB = Axis Aligned Bounding Box。</p>
<h3 id="光线与aabb是否相交"><a class="header" href="#光线与aabb是否相交">光线与AABB是否相交</a></h3>
<p>以二维情况为例，长方形为2个不同的对面（slab）形成的交集。 </p>
<ol>
<li>求光线与x轴方向上的两个对面相交的时间，tmin和tmax</li>
</ol>
<p><img src="RayTracing/../assets/17.PNG" alt="" /></p>
<ol start="2">
<li>求光线与y轴方向上的两个对面相交的时间，tmin和tmax</li>
</ol>
<p><img src="RayTracing/../assets/95.PNG" alt="" /></p>
<ol start="3">
<li>光线进入 AABB 的时间为所有[tmin, tmax] 的交集</li>
</ol>
<p><img src="RayTracing/../assets/96.PNG" alt="" /></p>
<ol start="4">
<li>分析光线与AABB的相交情况</li>
</ol>
<p>tenter = max{tmin}, texit = min{tmax}</p>
<p>tenter &lt; texit &amp;&amp; texit &gt; 0⇒ 光线与AABB 相交</p>
<p>texit &lt; 0 || tenter &gt; texit ⇒ 不相交</p>
<p>tenter &lt; 0 &lt; texit ⇒ 光源在 AABB 内</p>
<blockquote>
<p>❗ 以上方法对三维同样适用。计算每对平面的tmin和tmax，然后求交集。<br />
💡 对于凸多边形（体），判断点是否在内部，常规方法是依次判断点是否在边（面）的同一侧。但AABB的特点在于两条边（面）是平行的，因此可以一次判断点跟两条边（面）的关系。</p>
</blockquote>
<h3 id="求光线与slab相交的时间"><a class="header" href="#求光线与slab相交的时间">求光线与slab相交的时间</a></h3>
<p>Q:为什么要用 AABB？
A:光线与Axis Aligned平面求交的计算简单</p>
<table><thead><tr><th>普通平面</th><th>AA平面</th></tr></thead><tbody>
<tr><td><img src="RayTracing/../assets/97.PNG" alt="" /></td><td><img src="RayTracing/../assets/98.PNG" alt="" /></td></tr>
<tr><td>\(t = \frac{(p'- o) \dot N}{d \dot N}\)</td><td>\(t = \frac{(p'_x- o_x) }{d_x}\)</td></tr>
</tbody></table>
<h2 id="利用-aabb-加速-场景中的光线与所有物体求交的过程"><a class="header" href="#利用-aabb-加速-场景中的光线与所有物体求交的过程">利用 AABB 加速 场景中的光线与所有物体求交的过程</a></h2>
<h3 id="均匀的格子-uniform-grids"><a class="header" href="#均匀的格子-uniform-grids">均匀的格子 Uniform Grids</a></h3>
<blockquote>
<p>✅ <strong>算法前提：光线与 Grid 求交很快，与 object 求交很慢</strong>
💡 对于复杂操作，先进行快而粗的处理，再进行慢而精的处理，是常见做法。也可以是两者同时进行，前者相当于剪枝。</p>
</blockquote>
<p>所设有以下的场景：</p>
<p><img src="RayTracing/../assets/99.PNG" alt="" /></p>
<ol>
<li>找到场景的 Bounding Volumn</li>
</ol>
<blockquote>
<p>📌上图中的黑色边框就是BV</p>
</blockquote>
<ol start="2">
<li>BV划分成格子</li>
</ol>
<p><img src="RayTracing/../assets/100.PNG" alt="" /></p>
<ol start="3">
<li>判断每个 Grid 是否有物体，即判断格子和物体表面是否相交</li>
</ol>
<p><img src="RayTracing/../assets/101.PNG" alt="" /></p>
<ol start="4">
<li>判断光线与 Grid 是否相交，</li>
</ol>
<p><img src="RayTracing/../assets/102.PNG" alt="" /></p>
<ol start="5">
<li>如果Grid内有 object且光线与Grid相交，再计算光线与 grid 内的 object 是否相交</li>
</ol>
<p>算法特点：</p>
<ol>
<li>grid 不能太疏或密</li>
<li>适用于 object 的大小接近且位置均匀</li>
<li>不适用于 object 分布不均匀的场景</li>
</ol>
<blockquote>
<p>❓ 什么是位置均匀的？我的理解是稀疏，也就是通过AABB排除的部分越多越好。</p>
</blockquote>
<h3 id="空间划分-spatial-partition"><a class="header" href="#空间划分-spatial-partition">空间划分 Spatial Partition</a></h3>
<p><img src="RayTracing/../assets/103.PNG" alt="" /></p>
<ul>
<li>Octree：八叉树，仅在必要的时候继续切，每次切成同样大小的八块。高维度时每一次都要划分出很多块，出现维度灾难。</li>
<li>KD tree：与八叉树的区别是，每次只选择沿着一个轴方向进行切分，且不一定从中间切</li>
<li>BSP tree：与KD tree的区别是，不一定沿着轴方向切。因此在计算光线与平面的交点时没那么方便，且维度越高越难计算。</li>
</ul>
<p>视频以KD Tree 为例子。</p>
<h4 id="构造kd-tree"><a class="header" href="#构造kd-tree">构造KD Tree</a></h4>
<p><img src="RayTracing/../assets/104.PNG" alt="" /></p>
<ul>
<li>中间结点</li>
</ul>
<p>划分轴：x,y,z轴轮流<br />
划分点：根据特定的策略选择<br />
child: 2个<br />
object: 不存 object 数据</p>
<ul>
<li>叶子结色<br />
存 list of objects.</li>
</ul>
<h4 id="traverse"><a class="header" href="#traverse">Traverse.</a></h4>
<p>递归进行。<br />
如果光线与某个中间结点相交，则继续判断中间结果的子结点，否则跳过。<br />
如果光线与某个叶子结果相交，则继续与叶子中存储的所有objects计算，否则跳过。</p>
<h4 id="局限性-3"><a class="header" href="#局限性-3">局限性</a></h4>
<ol>
<li>如何判断AABB包围盒与objects中的三角形相交。</li>
<li>object 可能存在于多个叶子结点中</li>
</ol>
<blockquote>
<p>✅ 基于空间划分，obj会重复。基于obj划分，空间会重复。</p>
</blockquote>
<h3 id="物体划分-object-partition"><a class="header" href="#物体划分-object-partition">物体划分 Object Partition</a></h3>
<p>BVH：Bounding Volumn Hierarchy</p>
<p>优点：解决以上2个问题<br />
局限性： BV 有重叠，好的划分使重叠尽量少</p>
<h4 id="create"><a class="header" href="#create">Create</a></h4>
<ol>
<li>计算 B V</li>
</ol>
<blockquote>
<p>✅ 对所有objects求包围盒的过程非常简单，解决了“判断AABB包围盒与objects中的三角形相交”的问题。</p>
</blockquote>
<ol start="2">
<li>对BV内的<strong>object</strong>划分</li>
</ol>
<blockquote>
<p>✅ 对object进行划分，解决了“object 可能存在于多个叶子结点中”的问题。<br />
✅ 已知BV，挑出在BV内的obj;已知obj，画出obj外的BV。</p>
</blockquote>
<p>以上两步交替进行</p>
<table><thead><tr><th>划分</th><th>生成树</th></tr></thead><tbody>
<tr><td><img src="RayTracing/../assets/105.PNG" alt="" /></td><td><img src="RayTracing/../assets/107.PNG" alt="" /></td></tr>
<tr><td><img src="RayTracing/../assets/106.PNG" alt="" /></td><td><img src="RayTracing/../assets/108.PNG" alt="" /></td></tr>
<tr><td><img src="RayTracing/../assets/109.PNG" alt="" /></td><td><img src="RayTracing/../assets/110.PNG" alt="" /></td></tr>
</tbody></table>
<p>但BVH引入了空间的相交。如何划分是效率的关键，好的划分应该让空间的相交尽量地少。<br />
通常选择对最长的轴进行划分，取中间的object作为划分点。当BV中的三角形个数少于门限时停止。</p>
<blockquote>
<p>🔎 给一堆无序的数，快速选择算法可以在O(n)的时间点找到第i大的数。</p>
</blockquote>
<h4 id="数据结构"><a class="header" href="#数据结构">数据结构</a></h4>
<ul>
<li>中间结点：</li>
</ul>
<p>包围盒、child: 2个</p>
<ul>
<li>叶子结色<br />
存 list of objects.</li>
</ul>
<h4 id="traverse-1"><a class="header" href="#traverse-1">Traverse</a></h4>
<p>同上</p>
<h3 id="kd-tree-vs-bvh"><a class="header" href="#kd-tree-vs-bvh">KD Tree VS. BVH</a></h3>
<p><img src="RayTracing/../assets/111.PNG" alt="" />
<img src="RayTracing/../assets/112.PNG" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概率论基础"><a class="header" href="#概率论基础">概率论基础</a></h1>
<p>省略，见<a href="https://windmissing.github.io/mathematics_basic_for_ML/">机器学习数学基础</a></p>
<p>PDF：概率密度函数</p>
<blockquote>
<p>✅ 前面是对问题的建模，现在开始是对问题的求解。<br />
解渲染方程有两个难点：（1）复杂函数的定积分（2）递归问题。使用Monte Carlo解决1，使用Russian轮盘赌解决2. 后面的改进方法解决特殊情况下普通的Monte Carlo不适用的问题。</p>
</blockquote>
<h1 id="复习渲染方程"><a class="header" href="#复习渲染方程">复习渲染方程</a></h1>
<p>复习渲染方程，回顾求积分的业务背景</p>
<p>$$
L_o(p, w_o) = L_e(p, w_o) + \int_{\Omega^+}L_i(p, w_i)f_r(p, w_i, w_o)(n\cdot w_i)dw_i
$$</p>
<p>其中：<br />
第一项：自己发的光<br />
Li：接收到的光<br />
fr：反射参数，与材料有关<br />
n*wi：夹角<br />
dwi：积累所有的方向</p>
<h1 id="蒙特卡罗积分-monto-carlo-integration"><a class="header" href="#蒙特卡罗积分-monto-carlo-integration">蒙特卡罗积分 Monto Carlo Integration</a></h1>
<h2 id="目标求任意函数的定积分int_abfxdx"><a class="header" href="#目标求任意函数的定积分int_abfxdx">目标：求任意函数的定积分\(\int_a^bf(x)dx\)</a></h2>
<p><img src="RayTracing/../assets/129.PNG" alt="" /></p>
<p>函数f(x)的在[a, b]区间内的定积分，其物理含义是图中阴影部分的面积。</p>
<p>但是f(x)比较复杂，难以从公式推导上去求解这个问题。</p>
<h2 id="黎曼积分"><a class="header" href="#黎曼积分">黎曼积分</a></h2>
<p>没听懂，大概是用某种方法简单地把阴影近似成一个或一些长方形，把长方形的面积当作是阴影的面积，因此求得的是近似值。</p>
<h2 id="蒙特卡罗积分"><a class="header" href="#蒙特卡罗积分">蒙特卡罗积分</a></h2>
<h3 id="原理-8"><a class="header" href="#原理-8">原理</a></h3>
<p>用另一种方法来估计阴影部分的面积。所估计出的面积也是近似值。</p>
<h3 id="方法"><a class="header" href="#方法">方法</a></h3>
<ol>
<li>在积分域内不断地采样，采样点为xi</li>
<li>采样点对应的value是f(xi)</li>
<li>多次采样，并对采样结果的value取平均</li>
<li>把阴影近似成一个长方形，长方形的宽为区域范围(b-a)，高为第3步的平均值</li>
</ol>
<p>则：<br />
$$
\int_a^bf(x)dx \approx E(f(x))(b-a)
$$</p>
<p>当采样次数越来越多，f(xi)的平均值逐渐接近f(x)的期望。也因此长方形的面积也会逐渐接近阴影面积的真实值。</p>
<h3 id="进一步理解"><a class="header" href="#进一步理解">进一步理解</a></h3>
<p>前面所说在积分域内随机采样，通常会理解为是均匀采样。实际上，用任意的采样函数做随机采样都是可行的。</p>
<p>例如使用概率密度函数：</p>
<p>$$
X_i \sim p(x)
$$</p>
<p>则：</p>
<p>$$
\int_a^bf(x)dx = \frac{1}{N}\sum\frac{f(X_i)}{p(X_i)}
$$</p>
<h3 id="特点-1"><a class="header" href="#特点-1">特点</a></h3>
<ol>
<li>只需要能对[a b]以一定方式采样，就可以求出定积分。<strong>对f(x)和p(x)都没有特殊的要求。</strong></li>
<li>采样次数越多，结果越准确。</li>
<li>积分域和采样域必须相同。</li>
</ol>
<blockquote>
<p>✅ p(x)至少要是一个pdf，且p(x)与f(x)的作用域相同。虽然对任意的p(x)，能得到正确的期望，但方差不同。p(x)与f(x)的形状越接近，方差越小。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="whitted-style-ray-tracing-的局限性2040"><a class="header" href="#whitted-style-ray-tracing-的局限性2040">Whitted-Style Ray Tracing 的局限性[20:40]</a></h1>
<blockquote>
<p>🔎 <a href="RayTracing/Whitted.html">Whitted-Style Ray Tracing</a></p>
</blockquote>
<ol>
<li>光线打到光滑材质，会发生镜面反射。 </li>
</ol>
<p><img src="RayTracing/../assets/130.PNG" alt="" /></p>
<p>因此只能做出镜面反射的效果，无法处理Glossy材质的反射效果</p>
<ol start="2">
<li>光线打到透明物体，不会折射</li>
<li>光线打到普通物体，会漫反射，然后停止</li>
</ol>
<blockquote>
<p>💡 因为它对反射的光线做了枚举，而枚举一定是有限的。渲染方程对反射光线做了统计，统计能反应真正的规律。</p>
</blockquote>
<p><img src="RayTracing/../assets/131.PNG" alt="" /></p>
<p>光线打到漫反射表面后就不在弹跳了，导致光源没有直接照的地方是黑的，例如天花板和物体的侧面。实际上漫反射的光线也应该继续弹跳，照亮天花板。左边的墙上的光线弹到对面的物体上，使物体侧面也呈现出红色(color bleeding效果)。</p>
<p>Whited Style 算法有局限性，但 rendering 公式是正确的。正确解出 rendering 公式，会得到正确的算法。</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pathtracing"><a class="header" href="#pathtracing">PathTracing</a></h1>
<p>渲染方程：</p>
<p>$$
L_o(p, w_o) = L_e(p, w_o) + \int_{\Omega^+}L_i(p, w_i)f_r(p, w_i, w_o)(n\cdot w_i)dw_i
$$</p>
<p>通过解渲染方程，可以得到正确的算法。</p>
<p>但它有以下两个难点：</p>
<ol>
<li>公式的第二项是一个定积分，比较难求，可以使用Monto Calio方法解出它的近似值。</li>
<li>这是一个递归公式。</li>
</ol>
<h1 id="用-monto-calio-方法解定积分"><a class="header" href="#用-monto-calio-方法解定积分">用 Monto Calio 方法解定积分</a></h1>
<h2 id="场景1"><a class="header" href="#场景1">场景1</a></h2>
<p>先考虑一个简单场景：</p>
<p><img src="RayTracing/../assets/132.PNG" alt="" /></p>
<p>只考虑这一个着色点、只考虑直接光照、且被照射点不发光。<br />
有一个物体会遮住部分、有一个较大的面光源。<br />
入射光线为上半球所有Wi，且均匀分布。出射光线为 Wo。<br />
求这个点接收到并向wo辐射的能量。</p>
<p>根据渲染方程，有：</p>
<p>$$
L_o(p, w_o) = \int_{\Omega^+}L_i(p, w_i)f_r(p, w_i, w_o)(n\cdot w_i)dw_i
$$</p>
<p>由于本场景假设<strong>只考虑直接光照</strong>，那么\(L_i(p, w_i)\)只来自于光源。</p>
<p>用Monto Carlio解定积分，假设使用均匀采样，将公式代入以上公式，可<strong>将连续问题转化为离散问题</strong>，得到：</p>
<table><thead><tr><th></th><th>采样函数</th><th>积分函数</th><th>积分结果</th></tr></thead><tbody>
<tr><td>理论上</td><td>\(X_k \sim p(x)\)</td><td>\(f(X_k)\)</td><td>\(\frac{1}{N}\sum\frac{f(X_i)}{p(X_i)}\)</td></tr>
<tr><td>实际上</td><td>\(\frac{1}{2\pi}\)</td><td>\(L_i(p, w_i)f_r(p, w_i, w_o)(n\cdot w_i)\)<br>均匀采样</td><td>\(\frac{2\pi}{N}L_i(p, w_i)f_r(p, w_i, w_o)(n\cdot w_i)\)</td></tr>
</tbody></table>
<p>其中wi来自采样</p>
<p><img src="RayTracing/../assets/135.PNG" alt="" /></p>
<blockquote>
<p>💡 连续问题往往比较难解。通过采样的方式把连续问题转化为离散问题，这样就只是需要考虑几个离散的点，就要好解得多。这是复杂问题简单化的一个思路。</p>
</blockquote>
<h2 id="场景2-引入间接光照"><a class="header" href="#场景2-引入间接光照">场景2 引入间接光照</a></h2>
<p><img src="RayTracing/../assets/133.PNG" alt="" /></p>
<p>P接收到的辐射不一定来自光源，也可以来自Q。<br />
P接收到的来自Q的辐射 = Q向P发出的辐射。<br />
对于P来说，辐射是来自直射光还是反射光，没有区别。</p>
<p><img src="RayTracing/../assets/134.PNG" alt="" /></p>
<p>$$
L_o(p, w_o) \approx \frac{1}{N} \sum \frac{func(w_i)}{1/2\pi}
$$</p>
<p>当wi来自光源时，</p>
<p>$$
fun = Li * Fr * cos
$$</p>
<p>当wi来自其它物体q时，</p>
<p>$$
fun = shade(q - wi) * fr * cos
$$</p>
<h2 id="场景3一根光线会向多个方向弹射"><a class="header" href="#场景3一根光线会向多个方向弹射">场景3：一根光线会向多个方向弹射</a></h2>
<p><img src="RayTracing/../assets/136.PNG" alt="" /></p>
<p>光线路径数\(rays = N^{bouns}\) 这个量级下计算量会爆炸</p>
<p>因此取 N = l (即 path tracing)，才不会发生爆炸。</p>
<p>即：每次使用Monto Calio求定积分时，只做一次采样。<br />
<img src="RayTracing/../assets/137.PNG" alt="" /></p>
<p>虽然N取1会导致这个path在求定积分这一步引入较大的噪声。但是穿过像素的不止这一个path。 path足够多时，多个path的平均会缓解N=1带来的噪声。</p>
<p><img src="RayTracing/../assets/138.PNG" alt="" /></p>
<p><img src="RayTracing/../assets/139.PNG" alt="" /></p>
<h1 id="如何解递归问题"><a class="header" href="#如何解递归问题">如何解递归问题</a></h1>
<p>从公式或者从上面的伪代码都能看出，这是一个递归问题。<br />
递归本身不是问题。问题是这里的递归没有停止条件，会无限地递归下去。</p>
<h2 id="人为定义-bounce-的次数"><a class="header" href="#人为定义-bounce-的次数">人为定义 bounce 的次数</a></h2>
<p>人为定义 bounce 的次数，当光线bounce这么多次（或者说递归到这个深度）后就强行停止。</p>
<p>这种方法能解决无限递归的问题，但会带来能量的损失。</p>
<h2 id="russian-roulette-俄罗斯轮盘赌"><a class="header" href="#russian-roulette-俄罗斯轮盘赌">Russian Roulette 俄罗斯轮盘赌</a></h2>
<p>即不明确定义次数，而是以一定概率p决定是否继续 bounce。以此算出能量Lo。<br />
最后使用Lo/p该点输出的能量。<br />
这个结果的期望与无限 bounce 的理论结果相同，因为：<br />
E = P * (Lo/ P) + (1-P) * 0 = Lo</p>
<p><img src="RayTracing/../assets/140.PNG" alt="" /></p>
<p><strong>到目前为止，已经得到一个正常的path tracing流程了。</strong></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="path-tracing-的性能与效率"><a class="header" href="#path-tracing-的性能与效率">Path Tracing 的性能与效率</a></h1>
<h2 id="现象-1"><a class="header" href="#现象-1">现象</a></h2>
<p><img src="RayTracing/../assets/141.PNG" alt="" /></p>
<blockquote>
<p>👆 图中上面是光源，中间是遮挡物。左：Low SPP。右：High SPP。</p>
</blockquote>
<p>SPP：sample per pixel。表示从一个像素出来的path数。SPP低，速度快，但noisy。SPP高，速度慢，但效果好。</p>
<p>怎样才能在Low SPP情况下得到好的效果？</p>
<blockquote>
<p>💡 具体问题具体分析。在什么情况下LOW SPP的影响会特别（不）严重。这些场景有什么特点？实验用来分析这种问题最有意义，而不是调参。</p>
</blockquote>
<h2 id="分析-1"><a class="header" href="#分析-1">分析</a></h2>
<p><img src="RayTracing/../assets/142.PNG" alt="" /></p>
<p>由于是从着色点均匀地向外随机采样，<br />
当光源大时，随机采样更容易遇到光源。
当光源小时，随机采样可能要采很多次才会遇到光源。而其它大多数采样次数都被“浪费”了。</p>
<h2 id="解决方法"><a class="header" href="#解决方法">解决方法</a></h2>
<p>解决方法：上半球均匀采样-&gt;只在光源上采样</p>
<p>由于MontoCalio方法不限制采样的PDF，可以定义更合理的PDF使得采样结果不浪费。那就是<strong>只在光源上采样</strong>。</p>
<blockquote>
<p>💡 如果我来做会指使高斯分布来采样.可以控制重点</p>
</blockquote>
<p><img src="RayTracing/../assets/143.PNG" alt="" /></p>
<p>右上角是光源。光源面积是A。那么在光源上采样的PDF是
：</p>
<p>$$
p(x) = \frac{1}{A}
$$</p>
<p>但现在的<strong>采样和积分不是针对同一个区间进行的</strong>。采样域是光面的所有面积，积分域是x点的所有立体角。因此<strong>通过光源位置与球面立体角的关系</strong>，把采样域和积分域的统一。可以是（1）改PDF函数，把光源采样的PDF转化成在球面立体角采样的PDF。（2）改积分函数，把立体角上的积分转化成在光源上的积分。在视频算法中选择了后者。</p>
<p>根据<a href="RayTracing/BasicRadiometry.html">立体角</a>的定义可知：</p>
<p>$$
d\omega = \frac{dA\cos\theta'}{||x'-x||^2}
$$</p>
<blockquote>
<p>❓ 听上去逻辑很顺，总感觉有点怪。上面这个公式要求A的面积不能太大。如果是一个大的光源，是不是要分解成很多小的dA?<br />
❓ 为什么dA不能太大？</p>
</blockquote>
<p>代入渲染方程可得：</p>
<p>$$
L_o(x, w_o) = \int_AL_i(x, w_i)f_r(x, w_i, w_o)\frac{\cos\theta\cos\theta'}{||x'-x||^2}dA
$$</p>
<h2 id="总结-1"><a class="header" href="#总结-1">总结</a></h2>
<p>以上优化是针对光源来做的，因此<strong>只用于直接光照</strong>。</p>
<blockquote>
<p>✅ 因为反射的光线可能来自任何地方，不可能对来源做枚举。</p>
</blockquote>
<p>因此这个优化算法是，直接光照和间接光照分开处理：</p>
<ul>
<li>直接光照在光源上积分，间接光照仍旧在立体角上积分。</li>
<li>直接光照不需要考虑“<a href="RayTracing/PathTracing.html">Russian Roulette</a>”，间接光照涉及多次弹射才需要。<br />
在光源上积分需要判断一个 sample 出的光线是否被挡住</li>
</ul>
<h1 id="光源被挡住"><a class="header" href="#光源被挡住">光源被挡住</a></h1>
<p><img src="RayTracing/../assets/144.PNG" alt="" /></p>
<p>遍历所有光源，并计算光源对x点的贡献，这里没有考虑光源被挡住的场景。</p>
<p><img src="RayTracing/../assets/145.PNG" alt="" /></p>
<p>解决方法：</p>
<p>判断xx'的连线上是否有其它物体。 </p>
<h1 id="效果-7"><a class="header" href="#效果-7">效果</a></h1>
<p><strong>照片级真实感</strong></p>
<p><img src="RayTracing/../assets/146.PNG" alt="" /></p>
<h1 id="其它"><a class="header" href="#其它">其它</a></h1>
<ol>
<li>点光源当成面积很小的光源处理</li>
<li>怎样基于一个pdf做采样？</li>
<li>怎么选择好的pdf?均匀采样→重要性采样</li>
<li>随机数质量对算法的影响</li>
<li>把上半球采样与光源采样结合起来</li>
<li>pixel reconstruction filter</li>
<li>radiance → color, gamma 校正</li>
</ol>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="heightfield"><a class="header" href="#heightfield">Heightfield</a></h1>
<p><img src="TerrainRendering/../assets/06-1-1.png" alt="" /></p>
<h2 id="render-terrain-with-heightfield"><a class="header" href="#render-terrain-with-heightfield">Render Terrain with Heightfield</a></h2>
<h3 id="朴素方法"><a class="header" href="#朴素方法">朴素方法</a></h3>
<p><img src="TerrainRendering/../assets/06-2.png" alt="" /></p>
<blockquote>
<p><img src="TerrainRendering/../assets/06-51.png" alt="" /></p>
</blockquote>
<p>存在的问题：数据量巨大</p>
<h3 id="adaptive-mesh-tessellation---level-of-detail"><a class="header" href="#adaptive-mesh-tessellation---level-of-detail">Adaptive Mesh Tessellation - Level Of Detail</a></h3>
<p>与角色 LOD 不同的是，地形是连续的。</p>
<p><img src="TerrainRendering/../assets/06-3.png" alt="" /></p>
<p>因此在同一个地形里同时存在不同的LOD。</p>
<h4 id="golden-rules-of-lod"><a class="header" href="#golden-rules-of-lod">Golden Rules of LOD</a></h4>
<p>(1) 近处密集，远处稀疏<br />
(2) FOV 小密集，FOV 大稀疏<br />
(3) 地型起伏大(有明显误差)密集，起伏小稀疏</p>
<h2 id="mesh-subdivision"><a class="header" href="#mesh-subdivision">Mesh Subdivision</a></h2>
<h3 id="triangle-based-and-t-junctions"><a class="header" href="#triangle-based-and-t-junctions">Triangle-Based and T-Junctions</a></h3>
<p>Continuously partitioning triangles and their<br />
children based on the idea of binary trees</p>
<p><img src="TerrainRendering/../assets/06-6.png" alt="" /></p>
<blockquote>
<p>T-Junction：一条边的两边切分不一致导致的 BuG。<br />
解决方法：强制稀疏侧向密集侧对齐</p>
</blockquote>
<h3 id="quadtree-based-subdivision"><a class="header" href="#quadtree-based-subdivision">QuadTree-Based Subdivision</a></h3>
<blockquote>
<p>三角形不符合构建地形的直觉，更常用是四边形。 </p>
</blockquote>
<p><img src="TerrainRendering/../assets/06-7.png" alt="" /></p>
<p><strong>Pros</strong></p>
<ul>
<li>Easy to construct</li>
<li>Easy management of data under geospatial, including objects culling and data streaming</li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li>Mesh subdivision is not as flexible as triangle mesh</li>
<li>The grid level of the leaf nodes needs to be consistent</li>
</ul>
<blockquote>
<p>也会有 T-Junctions 问题。解决方法：吸附。<br />
吸附不改变数据结构，实现更容易。</p>
</blockquote>
<p><img src="TerrainRendering/../assets/06-8.png" alt="" /></p>
<h3 id="triangulated-irregular-network-tin"><a class="header" href="#triangulated-irregular-network-tin">Triangulated Irregular Network (TIN)</a></h3>
<blockquote>
<p>把 height field 转化为不规则三角形。</p>
</blockquote>
<p><img src="TerrainRendering/../assets/06-9.png" alt="" /></p>
<p><strong>Pros</strong></p>
<ul>
<li>与地形特征更匹配(顶点的位置)，Easy in runtime rendeirng</li>
<li>Less triangls in certain terrain types</li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li>Requires certain pre-processing steps</li>
<li>Poor reusability<br />
但实际上不常用。</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="non-heightfield-terrain"><a class="header" href="#non-heightfield-terrain">Non-Heightfield Terrain</a></h1>
<blockquote>
<p>处理有山洞的地形</p>
</blockquote>
<h2 id="方法1在普通地形上放一个山洞或桥"><a class="header" href="#方法1在普通地形上放一个山洞或桥">方法1：在普通地形上放一个山洞或桥。</a></h2>
<h2 id="方法2dig-a-hole-in-terrain"><a class="header" href="#方法2dig-a-hole-in-terrain">方法2：Dig a Hole in Terrain</a></h2>
<p>通过将顶点设为无效值的方式把洞口的面片删掉，</p>
<p><img src="TerrainRendering/../assets/06-12.png" alt="" /></p>
<p>再放一个隧道的模型上去。 </p>
<h2 id="方法3volumetric-representation"><a class="header" href="#方法3volumetric-representation">方法3：Volumetric Representation</a></h2>
<p>In 3D computer graphics, a voxel represents a value on a regular grid in three-dimensional space. As pixels in a 2D<br />
bitmap, voxels themselves do not typically have their position (i.e. coordinates) explicitly encoded with their values</p>
<blockquote>
<p>用体素来表达世界，并用一个值来描述每个体素上是否有物质以及物质的密度。<br />
再有 <a href="TerrainRendering/">Marching Cube</a> 将其转为 Mesh。<br />
实操时，考虑到水密性、LOD 等因素，会稍微复杂一点。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="paint-terrain-materials"><a class="header" href="#paint-terrain-materials">Paint Terrain Materials</a></h1>
<h2 id="terrain-materials-splatting"><a class="header" href="#terrain-materials-splatting">Terrain Materials Splatting</a></h2>
<blockquote>
<p>Splat Map：每一个 channel 定义了一种材质的权重。又称为材质混合。 </p>
</blockquote>
<p><img src="TerrainRendering/../assets/06-14.png" alt="" /></p>
<h3 id="simple-texture-splatting"><a class="header" href="#simple-texture-splatting">Simple Texture Splatting</a></h3>
<p>简单的Texture Splatting会混合出为种效果：</p>
<p><img src="TerrainRendering/../assets/06-15-1.png" alt="" /></p>
<blockquote>
<p>但真实的材质过渡不是这种柔和渐变的过渡，而应该是这种：</p>
</blockquote>
<p><img src="TerrainRendering/../assets/06-15-2.png" alt="" /></p>
<h3 id="advanced-texture-splatting"><a class="header" href="#advanced-texture-splatting">Advanced Texture Splatting</a></h3>
<blockquote>
<p>解决方法：利用 height 调整权重</p>
</blockquote>
<p><img src="TerrainRendering/../assets/06-16-1.png" alt="" /></p>
<pre><code>float3 blend(float4 texture1, float height1, float4 texture2, float height2)    
{    
return height1 &gt; height2 ? texture1.rgb : texture2.rgb;    
}       
</code></pre>
<p><img src="TerrainRendering/../assets/06-16-2.png" alt="" /></p>
<h3 id="advanced-texture-splatting---biased"><a class="header" href="#advanced-texture-splatting---biased">Advanced Texture Splatting - Biased</a></h3>
<blockquote>
<p>存在的问题，相机移到时有抖动现象 
解决方法：引入 height bias</p>
</blockquote>
<p><img src="TerrainRendering/../assets/06-17-3.png" alt="" /></p>
<p><img src="TerrainRendering/../assets/06-17-2.png" alt="" /></p>
<blockquote>
<p><strong>Links:</strong> <a href="https://www.gamedeveloper.com/programming/advanced-terrain-texture-splatting">https://www.gamedeveloper.com/programming/advanced-terrain-texture-splatting</a></p>
</blockquote>
<h3 id="sampling-from-material-texture-array"><a class="header" href="#sampling-from-material-texture-array">Sampling from Material Texture Array</a></h3>
<p><img src="TerrainRendering/../assets/06-18.png" alt="" /></p>
<blockquote>
<p>实践中会用到很多帧图，通常把它们 patch 成 Texture Array。</p>
</blockquote>
<h3 id="expensive-material-blending"><a class="header" href="#expensive-material-blending">Expensive Material Blending</a></h3>
<ul>
<li>
<p><strong>Many Texturing</strong> - Low performance when multiple materials are sampled too many times</p>
</li>
<li>
<p><strong>Huge Splat Map</strong> - We only see a small set of terrain, but we load splat maps for 100 square km into video memory</p>
</li>
</ul>
<p><img src="TerrainRendering/../assets/06-20.png" alt="" /></p>
<blockquote>
<p>整个场景包含很多纹理，Texture Array 涉及内存的来回寻址，效率比较低。但实际上一个像素会用到的纹理种类很少。</p>
</blockquote>
<h2 id="virtual-texture"><a class="header" href="#virtual-texture">Virtual Texture</a></h2>
<ul>
<li>Build a virtual indexed texture to represent all blended terrain materials for whole scene</li>
<li>Only load materials data of tiles based on view- depend LOD</li>
<li>Pre-bake materials blending into tile and store them into physical textures</li>
</ul>
<p><img src="TerrainRendering/../assets/06-21.png" alt="" /></p>
<blockquote>
<p>思想，只把用到的纹理加到内存、其它的纹理放在硬盘中。类似于mipmap＋oS 分页机制。<br />
优点：(1) 极大地减少了显存的占用<br />
(2) 像素的 blending，在 tile 被加载到内存时算好就不动了，直到这个 tile 被置换出内存。</p>
</blockquote>
<p><strong>这个是目前的主流方法</strong>。</p>
<h1 id="floating-point-precision-error"><a class="header" href="#floating-point-precision-error">Floating-point Precision Error</a></h1>
<blockquote>
<p>浮点数的精度溢出<br />
float 存储数据时，数值越大精度越低。精度太低就会引起抖动。<br />
地图太大时，这种情况很常见。</p>
</blockquote>
<h2 id="camera-relative-rendering"><a class="header" href="#camera-relative-rendering">Camera-Relative Rendering</a></h2>
<blockquote>
<p>解决方法：坐标系调整到相机中心(很多引擎的标准做法)
仿真时也会有同样的问题。</p>
</blockquote>
<ul>
<li>Translates objects by the negated world space camera position before any other geometric transformations affect them</li>
<li>It then sets the world space camera position to 0 and modifies all relevant matrices accordingly</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sky-and-atmosphere"><a class="header" href="#sky-and-atmosphere">Sky and Atmosphere</a></h1>
<p><img src="Sky/../assets/06-23.png" alt="" /></p>
<blockquote>
<p>天空是一个球，云是可见的实体。背后是完全不同的表达方法，不可混为一谈。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atmosphere"><a class="header" href="#atmosphere">Atmosphere</a></h1>
<h2 id="participating-media"><a class="header" href="#participating-media">Participating Media</a></h2>
<h3 id="大气粒子的种类"><a class="header" href="#大气粒子的种类">大气粒子的种类</a></h3>
<ul>
<li>Volume filled with particles</li>
<li>Interact differently with light depending on its composition</li>
</ul>
<p><img src="Sky/../assets/06-27.png" alt="" /></p>
<blockquote>
<p>大气层有两种粒子构成:<br />
(1) 各种气体分子<br />
(2) 气溶胶<br />
这些是光的介质，是产生各种光学现象的原因。</p>
</blockquote>
<blockquote>
<p>气体分子直径远小于光的波长，气溶胶的直径与光的波长相似，因此表现出完全不同的视觉效果，也对应两种不同的模型。</p>
</blockquote>
<h3 id="how-light-interacts-with-participating-media-particles"><a class="header" href="#how-light-interacts-with-participating-media-particles">How Light Interacts with Participating Media Particles?</a></h3>
<p><img src="Sky/../assets/06-25-1.png" alt="" /></p>
<blockquote>
<p>(1) 吸收 (2) 散射 (3) 自发光</p>
</blockquote>
<p><img src="Sky/../assets/06-25-2.png" alt="" /></p>
<h3 id="volume-rendering-equation-vre"><a class="header" href="#volume-rendering-equation-vre">Volume Rendering Equation (VRE)</a></h3>
<p><img src="Sky/../assets/06-26-1.png" alt="" /></p>
<p><img src="Sky/../assets/06-26-2.png" alt="" /></p>
<blockquote>
<p>(1) 通透度 (2) 有多能量向视线方向辐射</p>
</blockquote>
<h2 id="气体分子散射模型---rayleigh-scattering"><a class="header" href="#气体分子散射模型---rayleigh-scattering">气体分子散射模型 - <strong>Rayleigh Scattering</strong></a></h2>
<p>Scattering of light by particles that have a diameter <strong>much smaller than</strong> the wavelength of the radiation (eg. air molecules)</p>
<p>Rayleigh，用于气体分子。特点：</p>
<ol>
<li>均匀散射</li>
<li>波长越短(紫)，散射越多</li>
<li>Certain directions receive more light than others front-back symmetry</li>
</ol>
<ul>
<li>Shorter wavelengths (eg. blue) are scattered more strongly than longer wavelengths (eg. red)</li>
</ul>
<p><img src="Sky/../assets/06-28.png" alt="" /></p>
<h3 id="rayleigh-scattering-equation"><a class="header" href="#rayleigh-scattering-equation">Rayleigh Scattering Equation</a></h3>
<p><img src="Sky/../assets/06-29.png" alt="" /></p>
<blockquote>
<p>\(\lambda\)：波长。\(\theta\)：夹用。\(h\)：海拔高度。</p>
</blockquote>
<h3 id="why-sky-is-blue"><a class="header" href="#why-sky-is-blue">Why Sky is Blue</a></h3>
<p><img src="Sky/../assets/06-30.png" alt="" /></p>
<h2 id="气溶胶散射模型---mie-scattering"><a class="header" href="#气溶胶散射模型---mie-scattering">气溶胶散射模型 - <strong>Mie scattering</strong></a></h2>
<p>Scattering of light by particles that have a diameter <strong>similar to or larger than</strong> the wavelength of the incident light (eg. aerosols)</p>
<p>Mie，用于气溶胶。特点：</p>
<ol>
<li>有方向性，沿着光的方向会强一点</li>
<li>对波长不敏感。</li>
</ol>
<p><img src="Sky/../assets/06-31.png" alt="" /></p>
<h3 id="mie-scattering-equation"><a class="header" href="#mie-scattering-equation">Mie Scattering Equation</a></h3>
<p><img src="Sky/../assets/06-32-1.png" alt="" /></p>
<ul>
<li>g &gt; 0, scatters more forward Mie scattering</li>
<li>g &lt; 0, scatters more backward</li>
<li>g = 0, Rayleigh scattering</li>
</ul>
<p><img src="Sky/../assets/06-32-2.png" alt="" /></p>
<h3 id="mie-scattering-in-daily-life"><a class="header" href="#mie-scattering-in-daily-life">Mie Scattering in Daily Life</a></h3>
<ul>
<li>Exhibit a strong forward directivity (halo effects around sun)</li>
<li>Scatter light of all wavelength nearly equally (fog effects)</li>
</ul>
<p><img src="Sky/../assets/06-33-1.png" alt="" /></p>
<p><img src="Sky/../assets/06-33-2.png" alt="" /></p>
<blockquote>
<p>\(O_3\) 和 \(CH_4\) 吸收短波，使物体表现出蓝色。<br />
假设空气中 \(O_3\) 和 \(CH_4\) 是均匀分布的。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="single-scattering-vs-multi-scattering"><a class="header" href="#single-scattering-vs-multi-scattering">Single Scattering vs. Multi Scattering</a></h1>
<p><img src="Sky/../assets/06-34.png" alt="" /></p>
<blockquote>
<p>Multi Scattering 现象与 GI 不同。因为空气中的粒子充满整个空间，所以 MS 的效果是连续的。</p>
</blockquote>
<h2 id="ray-marching"><a class="header" href="#ray-marching">Ray Marching</a></h2>
<ul>
<li><strong>Ray marching</strong> is a popular method to integrate function along a path</li>
<li>We use ray marching to calculate final radiance for a given point by single scattering</li>
<li>The integrated radiance is usually stored in <strong>look-up tables (LUT)</strong></li>
</ul>
<p><img src="Sky/../assets/06-36.png" alt="" /></p>
<h2 id="precomputed-atmospheric-scattering"><a class="header" href="#precomputed-atmospheric-scattering">Precomputed Atmospheric Scattering</a></h2>
<p><img src="Sky/../assets/06-37.png" alt="" /></p>
<p><a href="https://ebruneton.github.io/precomputed_atmospheric_scattering/">https://ebruneton.github.io/precomputed_atmospheric_scattering/</a></p>
<blockquote>
<p>空间采样、预计算、查表。</p>
</blockquote>
<p><img src="Sky/../assets/06-38.png" alt="" /></p>
<blockquote>
<p>人的视角 (2D)＋阳光角度 (2D) ＝4D<br />
如何参数化地表达 4D 数据</p>
</blockquote>
<p><strong>Multi Scattering LUT</strong></p>
<p><img src="Sky/../assets/06-39.png" alt="" /></p>
<blockquote>
<p>一般 N 取 3-4 够用了。预计算部算好，实时部分变得简单高效
非常经典的方法。<br />
大气环境不变前提下，人和太阳可以在任意位置，都能有比较好的效果。</p>
</blockquote>
<h2 id="challenges-of-precomputed-atmospheric-scattering"><a class="header" href="#challenges-of-precomputed-atmospheric-scattering">Challenges of Precomputed Atmospheric Scattering</a></h2>
<ul>
<li>Precomputation Cost
<ul>
<li>Multi-scattering iterations are very expensive</li>
<li>Hard to generate atmosphere LUT on low-end devices (ie. mobile)</li>
</ul>
</li>
<li>Authoring and <strong>Dynamic Adjustment of</strong> Environments
<ul>
<li>Artist can't change scattering coefficients on the fly</li>
<li>Hard to render effects like weather from sunny to rain fog, space travel among planets</li>
</ul>
</li>
<li>Runtime Rendering Cost
<ul>
<li>Expensive <strong>per-pixel multi high dimensional texture sampling</strong> for transmittance LUT and multi scattering LUT (always need to down-sample for efficiency)</li>
</ul>
</li>
</ul>
<p><strong>A Scalable and Production Ready Sky and Atmosphere Rendering Technique</strong><br />
<a href="https://diglib.eg.org/bitstream/handle/10.1111/cgf14050/v39i4pp013-022.pdf">https://diglib.eg.org/bitstream/handle/10.1111/cgf14050/v39i4pp013-022.pdf</a></p>
<h2 id="production-friendly-quick-sky-and-atmosphere-rendering"><a class="header" href="#production-friendly-quick-sky-and-atmosphere-rendering">Production Friendly Quick Sky and Atmosphere Rendering</a></h2>
<p>Simplify Multi-scattering Assumption</p>
<ul>
<li>Scattering events with order greater or equal to 2 are executed using an <strong>isotropic phase function</strong></li>
<li>All points within the neighborhood of the position we currently shade <strong>receive the same amount of second order scattered light</strong></li>
<li><strong>Visibility is ignored</strong></li>
</ul>
<p>$$
G_{n+1}=G_n\ast f _{ms}
$$</p>
<p>$$
\mathbf{ F_{ms}=1+f_{ms}+f^2_{ms}+f^3_{ms}+\dots = \frac{1}{1-\mathbf{f_{ms}} } }
$$</p>
<p>$$
\mathbf{\Psi _ {ms} }=\mathbf{L_ {2^{nd}order} F_ {ms} }
$$</p>
<blockquote>
<p>假设“散射是各向同性的”。那么，“均匀的入射光到均匀的出射光”的过程，只是一个简单的能衰减过程。所以只需要求出衰减比例，每 bounce 一次就按这个比例衰减就可以了。</p>
</blockquote>
<h2 id="production-friendly-quick-sky-and-atmosphere-rendering-1"><a class="header" href="#production-friendly-quick-sky-and-atmosphere-rendering-1">Production Friendly Quick Sky and Atmosphere Rendering</a></h2>
<p>Fixed view position and sun position to remove 2 dimensions out of LUT</p>
<p><img src="Sky/../assets/06-40.png" alt="" /></p>
<blockquote>
<p>对上文中的 LUT 的简化：<br />
(1) 假设人所在的高度不变，去掉 height 维<br />
(2) 假设太阳位置不变，去掉入射角的维度仅留下出射光的维度(天顶角、环角)</p>
</blockquote>
<h2 id="production-friendly-quick-sky-and-atmosphere-rendering-2"><a class="header" href="#production-friendly-quick-sky-and-atmosphere-rendering-2">Production Friendly Quick Sky and Atmosphere Rendering</a></h2>
<ul>
<li>Generated a 3D LUT to evaluate aerial-perspective effects by ray marching</li>
</ul>
<p><img src="Sky/../assets/06-41.png" alt="" /></p>
<blockquote>
<p>这个方法不保证物理正确，但好处是：<br />
(1) 艺术家友好<br />
(2) 可以创造异星世界效果<br />
(3) 硬件友好</p>
</blockquote>
<h2 id="good-balance-of-performance-and-effect"><a class="header" href="#good-balance-of-performance-and-effect">Good Balance of Performance and Effect</a></h2>
<ul>
<li>Scalable from mobile to high-end PCs</li>
</ul>
<p><img src="Sky/../assets/06-42.png" alt="" /></p>
<p>Performance for each step of method, as measured on PC (NV 1080) and a mobile device (iPhone 6s)</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="paint-cloud"><a class="header" href="#paint-cloud">&quot;Paint&quot; Cloud</a></h1>
<h2 id="cloud-type"><a class="header" href="#cloud-type">Cloud Type</a></h2>
<p><img src="Sky/../assets/06-43.png" alt="" /></p>
<h2 id="mesh-based-cloud-modeling"><a class="header" href="#mesh-based-cloud-modeling">Mesh-Based Cloud Modeling</a></h2>
<blockquote>
<p>Mesh＋腐蚀等算法。</p>
</blockquote>
<p><img src="Sky/../assets/06-44.png" alt="" /></p>
<p><strong>Pros</strong></p>
<ul>
<li>High quality</li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li>Overall expensive</li>
<li>Do not support dynamic weather</li>
</ul>
<p>现在已经没人用了。</p>
<h2 id="billboard-cloud"><a class="header" href="#billboard-cloud">Billboard Cloud</a></h2>
<blockquote>
<p>半透明插片＋\(\alpha \) 混合<br />
十年前常用</p>
</blockquote>
<p><strong>Pros</strong></p>
<ul>
<li>Efficient</li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li>Limited visual effect</li>
<li>Limited cloud type</li>
</ul>
<p><img src="Sky/../assets/06-45.png" alt="" /></p>
<h2 id="volumetric-cloud-modeling"><a class="header" href="#volumetric-cloud-modeling">Volumetric Cloud Modeling</a></h2>
<p><img src="Sky/../assets/06-46.png" alt="" /></p>
<p><strong>Pros</strong></p>
<ul>
<li>Realistic cloud shapes</li>
<li>Large scale clouds possible</li>
<li>Dynamic weather supported</li>
<li>Dynamic volumetric lighting and shadowing</li>
</ul>
<blockquote>
<p>优点：(1) 全动态，CPU 实时生成。(2) 云可以表现出很多变化</p>
</blockquote>
<p><strong>Cons</strong></p>
<ul>
<li>Efficiency must be considered</li>
</ul>
<blockquote>
<p>局限性：(1) 复杂 (2) expensive</p>
</blockquote>
<h2 id="weather-texture"><a class="header" href="#weather-texture">Weather Texture</a></h2>
<p><img src="Sky/../assets/06-47-1.png" alt="" /></p>
<p><img src="Sky/../assets/06-47-2.png" alt="" /></p>
<blockquote>
<p>texture＋厚度 channel<br />
对 texture 做挠动可以产生云的变化。</p>
</blockquote>
<h3 id="noise-functions"><a class="header" href="#noise-functions">Noise Functions</a></h3>
<p><img src="Sky/../assets/06-48-1.png" alt="" /></p>
<p><img src="Sky/../assets/06-48-2.png" alt="" /></p>
<h3 id="cloud-density-model"><a class="header" href="#cloud-density-model">Cloud Density Model</a></h3>
<p><img src="Sky/../assets/06-49.png" alt="" /></p>
<blockquote>
<p>用低频 noise 雕刻出造型，再用高频加上细节。</p>
</blockquote>
<h2 id="rendering-cloud-by-ray-marching"><a class="header" href="#rendering-cloud-by-ray-marching">Rendering Cloud by Ray Marching</a></h2>
<p><img src="Sky/../assets/06-50.png" alt="" /></p>
<blockquote>
<p>不会把云转成 Mesh 去渲染，而是当作大气来渲染。<br />
但由于云的通透性很低，可以对公式作大量假设和简化。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fog"><a class="header" href="#fog">Fog</a></h1>
<h2 id="depth-fog"><a class="header" href="#depth-fog">Depth Fog</a></h2>
<blockquote>
<p>随着距离降低透明度。</p>
</blockquote>
<p>Linear fog:<br />
factor = (end-z)/(end-start)</p>
<p>Exp fog:<br />
factor = exp(- density\(\ast \)z)</p>
<p><strong>Exp Squared fog:</strong><br />
factor = exp(- (density\(\ast \)z)^2)</p>
<p><img src="Sky/../assets/07-11.png" alt="" /></p>
<h2 id="height-fog"><a class="header" href="#height-fog">Height Fog</a></h2>
<ul>
<li>Height Fog integration along view diretion</li>
</ul>
<p>$$
\mathrm{D(h)=D _{max}\cdot e ^{-\sigma \cdot max(h-H _s,0)}}
$$</p>
<p>$$
\begin{align*}
= &amp; \mathrm {D_{\max}\cdot d\int_{0}^{1}e^{-\sigma \cdot \max (v_z+t\ast d_z-H_s,0)}dt} \\
= &amp; \mathrm {D_{\max}\cdot d\cdot e^{-\sigma \cdot \max(v_z-Hs,0)}\frac{1-e^{-\sigma \cdot d_z}}{\sigma \cdot d_z}}
\end{align*}
$$</p>
<ul>
<li>Fog color after transmission</li>
</ul>
<p>FogInscatter=1\(- \)exp\(^{-FogDensityIntegration}\)<br />
FinalColor=FogColor\(\cdot\) FogInscatter</p>
<p><img src="Sky/../assets/07-12.png" alt="" /></p>
<blockquote>
<p>十年前的常用方法。</p>
</blockquote>
<h2 id="voxel-based-volumetric-fog"><a class="header" href="#voxel-based-volumetric-fog">Voxel-based Volumetric Fog</a></h2>
<blockquote>
<p>根据视锥构造非均匀体素。<br />
计算方法与上一节的体素云类似。<br />
可以构造出雾中的光柱效果。</p>
</blockquote>
<p><img src="Sky/../assets/07-13-1.png" alt="" /></p>
<h2 id="anti-aliasing"><a class="header" href="#anti-aliasing">Anti-aliasing</a></h2>
<blockquote>
<p>反走样。</p>
</blockquote>
<h2 id="reason-of-aliasing"><a class="header" href="#reason-of-aliasing">Reason of Aliasing</a></h2>
<ul>
<li>Aliasing is a series of rendering artifact which is caused by high-frequency signal vs. insufficient sampling of limited rendering resolutions</li>
</ul>
<p><img src="Sky/../assets/07-14.png" alt="" /></p>
<blockquote>
<p>走样的本质：渲染的采样频率与真实世界的频率不一致。</p>
</blockquote>
<h2 id="anti-aliasing-1"><a class="header" href="#anti-aliasing-1">Anti-aliasing</a></h2>
<ul>
<li>The general strategy of screen-based antialiasing schemes is using a sampling pattern to <strong>get more samples</strong> and then <strong>weight and sum samples</strong> to produce a pixel color</li>
</ul>
<p>$$
p(x,y)=\sum_{i=1}^{n}  w_ic(i,x,y)
$$</p>
<p><img src="Sky/../assets/07-15-1.png" alt="" /></p>
<p><img src="Sky/../assets/07-15-2.png" alt="" /></p>
<blockquote>
<p>多采样再取平均，产生过渡区域。</p>
</blockquote>
<h2 id="super-sample-aa-ssaa-and-multi-sample-aa-msaa"><a class="header" href="#super-sample-aa-ssaa-and-multi-sample-aa-msaa">Super-sample AA (SSAA) and Multi-sample AA (MSAA)</a></h2>
<ul>
<li>Super sampling is the most straightforward solution to solve <strong>AA</strong></li>
</ul>
<p><img src="Sky/../assets/07-16-1.png" alt="" /></p>
<p><img src="Sky/../assets/07-16-2.png" alt="" /></p>
<blockquote>
<p>目前硬件部已支持 MSAA。<br />
但现在的高精模型可能比一个像素还小，这种方法就失效了。</p>
</blockquote>
<h2 id="fxaa-fast-approximate-anti-aliasing-1"><a class="header" href="#fxaa-fast-approximate-anti-aliasing-1">FXAA (Fast Approximate Anti-aliasing)</a></h2>
<p>Anti-aliasing based on 1x rendered image　</p>
<ul>
<li>Find edge pixels by luminance　　　</li>
<li>Compute offset for every edge pixel　　　</li>
<li>Re-sample edge pixel by its offset to blend with a neighbor　　　</li>
</ul>
<p><img src="Sky/../assets/07-17-1.png" alt="" /></p>
<p><img src="Sky/../assets/07-17-2.png" alt="" /></p>
<blockquote>
<p>提取边界，并在边界做插值。<br />
优点：(1) 效果好<br />
(2) 速度快，利用 GPU 的并行计算，没有多余的计算。<br />
(3) 计算简单。</p>
</blockquote>
<h2 id="edge-searching-algorithm-1"><a class="header" href="#edge-searching-algorithm-1">Edge Searching Algorithm</a></h2>
<p><img src="Sky/../assets/07-18-1.png" alt="" /></p>
<p><img src="Sky/../assets/07-18-2.png" alt="" /></p>
<h2 id="calculate-blend-coefficient-1"><a class="header" href="#calculate-blend-coefficient-1">Calculate Blend Coefficient</a></h2>
<ul>
<li>Compute blender coefficient</li>
</ul>
<p><strong>targetP</strong> is the nearer edge end of <strong>CurrentP</strong></p>
<p><img src="Sky/../assets/07-19-2.png" alt="" /></p>
<p><img src="Sky/../assets/07-19-5.png" alt="" /></p>
<p><img src="Sky/../assets/07-19-4.png" alt="" /></p>
<h2 id="blend-nearby-pixels-1"><a class="header" href="#blend-nearby-pixels-1">Blend Nearby Pixels</a></h2>
<ul>
<li>Compute blender coefficient</li>
</ul>
<p><img src="Sky/../assets/07-20.png" alt="" /></p>
<p><strong>PixelNewColor = Texture(CurrentP_UV + offset_direction * offset_magnitude )</strong></p>
<h2 id="fxaa-result"><a class="header" href="#fxaa-result">FXAA Result</a></h2>
<p><img src="Sky/../assets/07-21.png" alt="" /></p>
<h2 id="taa-temporal-anti-aliasing-1"><a class="header" href="#taa-temporal-anti-aliasing-1">TAA (Temporal Anti-aliasing)</a></h2>
<p>Utilize spatial-<strong>temporal</strong> filtering methods to improve AA stability <strong>in motion</strong></p>
<p><img src="Sky/../assets/07-22-1.png" alt="" /></p>
<p><img src="Sky/../assets/07-22-2.png" alt="" /></p>
<blockquote>
<p>引擎中的主流方法。</p>
</blockquote>
<h2 id="taa-temporal-anti-aliasing-2"><a class="header" href="#taa-temporal-anti-aliasing-2">TAA (Temporal Anti-aliasing)</a></h2>
<p><img src="Sky/../assets/07-23.png" alt="" /></p>
<h2 id="post-process"><a class="header" href="#post-process">Post-process</a></h2>
<p>Post-process in 3D Graphics refers to any algorithm that will be applied to the final image. It can be done for stylistic reasons (color correction, contrast, etc.) or for realistic reasons (tone mapping, depth of field, etc.)</p>
<p><img src="Sky/../assets/07-24.png" alt="" /></p>
<h2 id="bloom-effect"><a class="header" href="#bloom-effect">Bloom Effect</a></h2>
<h2 id="what-is-bloom"><a class="header" href="#what-is-bloom">What is Bloom</a></h2>
<ul>
<li>The physical basis of bloom is that, in the real world, lenses can never focus perfectly</li>
<li>Even a perfect lens will convolve the incoming image with an <u><strong>Airy disk</strong></U></li>
</ul>
<p><img src="Sky/../assets/07-25.png" alt="" /></p>
<h2 id="detect-bright-area-by-threshold"><a class="header" href="#detect-bright-area-by-threshold">Detect Bright Area by Threshold</a></h2>
<p><img src="Sky/../assets/07-26.png" alt="" /></p>
<p>Find Luminance (Y) apply the standard coefficients for sRGB:</p>
<p>$$
Y=R_{lin}\ast 0.2126+G_{lin}\ast 0.7152+B_{lin}\ast 0.0722
$$</p>
<blockquote>
<p>取出非常亮的部分，做与 5\(\times \)5 高斯 blur。</p>
</blockquote>
<h2 id="gaussian-blur"><a class="header" href="#gaussian-blur">Gaussian Blur</a></h2>
<p><img src="Sky/../assets/07-27.png" alt="" /></p>
<h2 id="pyramid-guassian-blur"><a class="header" href="#pyramid-guassian-blur">Pyramid Guassian Blur</a></h2>
<p><img src="Sky/../assets/07-28.png" alt="" /></p>
<p>We can't do all that filtering at high resolution, so we need a way to <strong>downsample</strong> and <strong>upsample</strong> the image Need a weight coefficient to tweak final effect</p>
<blockquote>
<p>在低精度图上 blur 再放大，可以得到大区域的 blur 效果同时较小的计算量。</p>
</blockquote>
<h2 id="bloom-composite"><a class="header" href="#bloom-composite">Bloom Composite</a></h2>
<p><img src="Sky/../assets/07-29.png" alt="" /></p>
<p><img src="Sky/../assets/07-30.png" alt="" /></p>
<h2 id="tone-mapping"><a class="header" href="#tone-mapping">Tone Mapping</a></h2>
<blockquote>
<p>真实世界的亮度 range 非常大，如果曝光没调好，会出现亮部过亮或暗部过暗的效果。</p>
</blockquote>
<h2 id="tone-mapping-1"><a class="header" href="#tone-mapping-1">Tone Mapping</a></h2>
<ul>
<li>No way to directly display HDR image in a SDR device</li>
<li>The purpose of the <strong>Tone Mapping</strong> function is to map the wide range of high dynamic range (HDR) colors into standard dynamic range (SDR) that a display can output</li>
</ul>
<p><img src="Sky/../assets/07-31.png" alt="" /></p>
<blockquote>
<p>用一条曲线把 HDR 映射到 SDR。<br />
filmic curve 是一个拟合出来的所项式曲线。</p>
</blockquote>
<h2 id="aces"><a class="header" href="#aces">ACES</a></h2>
<ul>
<li><strong>A</strong>cademy <strong>C</strong>olor <strong>E</strong>ncoding <strong>S</strong>ystem
<ul>
<li>Primarily for Film &amp; Animation</li>
<li>Interesting paradigms and transformations</li>
</ul>
</li>
<li>The useful bits
<ul>
<li>Applying Color Grading in HDR is good</li>
<li>The idea of a fixed pipeline up to the final OTD transforms stage is good
<ul>
<li>Separates artistic intent from the mechanics of supporting different devices</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="Sky/../assets/07-32-1.png" alt="" /></p>
<blockquote>
<p>ACES 曲线不但效果更好，还可以通注增加一个后处理，无差别适配到任何终端。</p>
</blockquote>
<h2 id="hdr-and-sdr-pipeline"><a class="header" href="#hdr-and-sdr-pipeline">HDR and SDR Pipeline</a></h2>
<ul>
<li>Visual consistency between HDR / SDR</li>
<li>Similar SDR results to previous SDR color pipeline</li>
<li>High quality</li>
<li>High performance</li>
<li>Minimal disruption to art teams
<ul>
<li>Simple transition from current color pipeline</li>
<li>Minimal additional overhead for mastering HDR <em>and</em> SDR</li>
</ul>
</li>
</ul>
<p><img src="Sky/../assets/07-33.png" alt="" /></p>
<h2 id="tone-mapping-curve-comparison"><a class="header" href="#tone-mapping-curve-comparison">Tone Mapping Curve Comparison</a></h2>
<p><img src="Sky/../assets/07-34-1.png" alt="" /><br />
<img src="Sky/../assets/07-34-2.png" alt="" /></p>
<h2 id="color-grading"><a class="header" href="#color-grading">Color Grading</a></h2>
<h2 id="lookup-table-lut"><a class="header" href="#lookup-table-lut">Lookup Table (LUT)</a></h2>
<ul>
<li>
<p>LUT is used to remap the input color values of source pixels to new output values based on data contained within the LUT</p>
</li>
<li>
<p>A LUT can be considered as a kind of color preset that can be applied to image or footage</p>
</li>
</ul>
<p><img src="Sky/../assets/07-35.png" alt="" /> </p>
<blockquote>
<p>用一个表格实现从原始色相空间到目标色相空间的映射。</p>
</blockquote>
<h2 id="rendering-pipeline"><a class="header" href="#rendering-pipeline">Rendering Pipeline</a></h2>
<h2 id="rendering-pipeline-1"><a class="header" href="#rendering-pipeline-1">Rendering Pipeline</a></h2>
<ul>
<li><strong>Rendering pipeline</strong> is the management order of all rendering operation execution and resource allocation</li>
</ul>
<p><img src="Sky/../assets/07-36.png" alt="" /> </p>
<h2 id="forward-rendering"><a class="header" href="#forward-rendering">Forward Rendering</a></h2>
<p>for n meshes<br />
\(\quad\) for m lights<br />
\(\quad \quad\)color += shading(mesh, light)</p>
<h2 id="sort-and-render-transparent-after-opaque-objects"><a class="header" href="#sort-and-render-transparent-after-opaque-objects">Sort and Render Transparent after Opaque Objects</a></h2>
<p><img src="Sky/../assets/07-37.png" alt="" /> </p>
<blockquote>
<p>透明物质必须最后绘制。<br />
多个透明物质则由远及近绘制，因为不同绘制顺序产生的结果是不一样的。<br />
透明物体的排序很容易引起各种 BuG。<br />
十几年前的主流 Pipeline。</p>
</blockquote>
<h2 id="deferred-rendering"><a class="header" href="#deferred-rendering">Deferred Rendering</a></h2>
<p><img src="Sky/../assets/07-38-1.png" alt="" /></p>
<p><img src="Sky/../assets/07-38-2.png" alt="" /> </p>
<p><img src="Sky/../assets/07-38-3.png" alt="" /> </p>
<p><img src="Sky/../assets/07-38-4.png" alt="" /> </p>
<blockquote>
<p>由于光的种类非常复杂，引入延迟渲染技术，即先绘制物体，再考虑与光的关系。<br />
近十年最主流的 Pipeline.</p>
</blockquote>
<h2 id="deferred-rendering-1"><a class="header" href="#deferred-rendering-1">Deferred Rendering</a></h2>
<p><strong>Pros</strong></p>
<ul>
<li>Lighting is only computed for visible fragments</li>
<li>The data from the G-Buffer can be used for post- processing</li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li>High memory and bandwidth cost</li>
<li>Not supporting transparent object</li>
<li>Not friendly to MSAA</li>
</ul>
<p><img src="Sky/../assets/07-39.png" alt="" /></p>
<h2 id="pilot-engine-deferred-rendering"><a class="header" href="#pilot-engine-deferred-rendering">Pilot Engine Deferred Rendering</a></h2>
<p><img src="Sky/../assets/07-40.png" alt="" /></p>
<h2 id="tile-based-rendering"><a class="header" href="#tile-based-rendering">Tile-based Rendering</a></h2>
<p><img src="Sky/../assets/07-41-1.png" alt="" /></p>
<p><img src="Sky/../assets/07-41-2.png" alt="" /></p>
<p><img src="Sky/../assets/07-41-3.png" alt="" /></p>
<blockquote>
<p>这个 pipeline 用于移动端。因为移动端最关心发热问题。<br />
DRAM 存储大、速度慢、功耗高。On-chip 中的 SRAM 则相反。<br />
因此，把整个 G-buffer 切成小的 tile 在 SRAM 计算，算好存成framebuffer。</p>
</blockquote>
<h2 id="light-culling-by-tiles"><a class="header" href="#light-culling-by-tiles">Light Culling by Tiles</a></h2>
<p><img src="Sky/../assets/07-42.png" alt="" /></p>
<h2 id="depth-range-optimization"><a class="header" href="#depth-range-optimization">Depth Range Optimization</a></h2>
<ul>
<li>Get Min/Max depth per tile from Pre-z pass</li>
<li>Test depth bounds for each light</li>
</ul>
<p><img src="Sky/../assets/07-43.png" alt="" /></p>
<blockquote>
<p>tile-based 是现代引擎的主流方案。<br />
tile 的额外好处是简化光的计算。</p>
</blockquote>
<h2 id="forward-tile-based-forward-rendering"><a class="header" href="#forward-tile-based-forward-rendering">Forward+ (Tile-based Forward) Rendering</a></h2>
<ul>
<li>Depth prepass (prevent overdraw / provide tile depth bounds)</li>
<li>Tiled light culling (output: light list per tile)</li>
<li>Shading per object (PS: Iterate through light list calculated in light culling)</li>
</ul>
<h2 id="cluster-based-rendering"><a class="header" href="#cluster-based-rendering">Cluster-based Rendering</a></h2>
<p><img src="Sky/../assets/07-44.png" alt="" /></p>
<blockquote>
<p>对 Z 空间也做切分。一个小块称为 cluster。</p>
</blockquote>
<h2 id="visibility-buffer"><a class="header" href="#visibility-buffer">Visibility Buffer</a></h2>
<p><img src="Sky/../assets/07-45.png" alt="" /></p>
<blockquote>
<p>几何信息 (V-Buffer) 和材质信息 (G-Buffer) 剥离开。<br />
因为现在的几何越来越复杂，甚至几何密度超过像素密度。<br />
这是现代引擎的发展方向。</p>
</blockquote>
<p><img src="Sky/../assets/07-46.png" alt="" /></p>
<h2 id="challenges"><a class="header" href="#challenges">Challenges</a></h2>
<ul>
<li>Complex parallel work needs to synchronize with complex resource dependency</li>
<li>Large amount of transient resource whose lifetime is shorter than one frame</li>
<li>Complex resource state management</li>
<li>Exploit newly exposed GPU features without extensive user low level knowledge</li>
</ul>
<h2 id="frame-graph"><a class="header" href="#frame-graph">Frame Graph</a></h2>
<p>A Directed Acyclic Graph (DAG) of pass and resource dependency in a frame, not a real visual graph</p>
<p><img src="Sky/../assets/07-47.png" alt="" /></p>
<blockquote>
<p>Frame Graph 是未来重要的发展方向。</p>
</blockquote>
<h2 id="render-to-monitor"><a class="header" href="#render-to-monitor">Render to Monitor</a></h2>
<h2 id="screen-tearing"><a class="header" href="#screen-tearing">Screen Tearing</a></h2>
<p><img src="Sky/../assets/07-48.png" alt="" /></p>
<h2 id="screen-tearing-1"><a class="header" href="#screen-tearing-1">Screen Tearing</a></h2>
<p>In most games your GPU frame rate will be highly volatile<br />
When new GPU frame updates in the middle of last screen frame, screen tearing occurrs</p>
<p><img src="Sky/../assets/07-49.png" alt="" /></p>
<h2 id="v-sync-technology"><a class="header" href="#v-sync-technology">V-Sync Technology</a></h2>
<p>Synchronizing buffer swaps with the Vertical refresh is called V-sync<br />
V-Sync can be used to prevent tearing but framerates are reduced, the mouse is lagging &amp; stuttering ruins gameplay</p>
<p><img src="Sky/../assets/07-50.png" alt="" /></p>
<h2 id="variable-refresh-rate"><a class="header" href="#variable-refresh-rate">Variable Refresh Rate</a></h2>
<p><img src="Sky/../assets/07-51.png" alt="" /></p>
<h2 id="homework-2"><a class="header" href="#homework-2">Homework 2</a></h2>
<ul>
<li>
<p>You are supposed to...</p>
<ul>
<li>Implement ColorGrading shader code</li>
<li>Generate own style ColorGrading result</li>
<li>Add a new post-process pass that you want (advanced)</li>
<li>Write a report document that contains screenshots of
your results</li>
</ul>
</li>
<li>
<p>Download at</p>
<ul>
<li>Course-site:<br />
<a href="https://games104.boomingtech.com/sc/course-list">https://games104.boomingtech.com/sc/course-list</a></li>
<li>Github:<br />
<a href="https://github.com/BoomingTech/Pilot/tree/games104/homework02-rendering">https://github.com/BoomingTech/Pilot/tree/games104/homework02-rendering</a></li>
</ul>
</li>
</ul>
<p><img src="Sky/../assets/07-52.png" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ambient-occlusion"><a class="header" href="#ambient-occlusion">Ambient Occlusion</a></h1>
<table><thead><tr><th>AO Off</th><th>AO On</th></tr></thead><tbody>
<tr><td><img src="AmbientOcclusion/../assets/07-1.png" alt="" /></td><td><img src="AmbientOcclusion/../assets/07-2.png" alt="" /></td></tr>
</tbody></table>
<blockquote>
<p>大脑对光影变化很敏感，因此可以通过光影构造空间理解。</p>
</blockquote>
<blockquote>
<p>由于附近几何的遮挡，有些点朝某些方向的光被挡住，产生了光影的效果。</p>
</blockquote>
<p><img src="AmbientOcclusion/../assets/07-3.png" alt="" /></p>
<h2 id="precomputed-ao"><a class="header" href="#precomputed-ao">Precomputed AO</a></h2>
<p>Using ray tracing to compute the AO offline and store the result into texture, which is widely used in object modeling process</p>
<ul>
<li>Extra storage cost</li>
<li>Only apply to static object</li>
</ul>
<p><img src="AmbientOcclusion/../assets/07-4.png" alt="" /></p>
<blockquote>
<p>对于有特点的角色，可以预计算 AO</p>
</blockquote>
<h2 id="screen-space-ambient-occlusion-ssao"><a class="header" href="#screen-space-ambient-occlusion-ssao">Screen Space Ambient Occlusion (SSAO)</a></h2>
<blockquote>
<p>对于一个场景，场景中对象的位置不固定，不能预计算。利用一个点周边的采样情况来估算它的被遮挡情况。</p>
</blockquote>
<ul>
<li>
<p>Generate N random samples in a sphere around each pixel p in view space</p>
</li>
<li>
<p>Test sample occlusions by comparing depth against depth buffer<br />
<img src="AmbientOcclusion/../assets/07-5.png" alt="" /></p>
</li>
<li>
<p>Average visibility of sample points to approximate AO</p>
</li>
</ul>
<p>$$
A(p)=1-\frac{Occlusion}{N} 
$$</p>
<p>公式不重要，重要的是思想：局部采样。</p>
<h2 id="ssao"><a class="header" href="#ssao">SSAO+</a></h2>
<blockquote>
<p>改进版：只采样半球。</p>
</blockquote>
<ul>
<li>Recall the AO equation is acutally done on the normal-oriented hemisphere</li>
</ul>
<p><img src="AmbientOcclusion/../assets/07-6-1.png" alt="" /></p>
<p><img src="AmbientOcclusion/../assets/07-6-2.png" alt="" /></p>
<h2 id="hbao---horizon-based-ambient-occlusion"><a class="header" href="#hbao---horizon-based-ambient-occlusion">HBAO - Horizon-based Ambient Occlusion</a></h2>
<blockquote>
<p>采样改成积分。</p>
</blockquote>
<p><img src="AmbientOcclusion/../assets/07-7-1.png" alt="" /></p>
<ul>
<li>Use the depth buffer as a heightfield on 2D surface</li>
<li>Rays that below the horizon angle are occluded</li>
</ul>
<p><img src="AmbientOcclusion/../assets/07-7-2.png" alt="" /></p>
<p>先计算一圈每个方向的仰角，可以估算出有多大面积的天顶是可见的。<br />
Attenuation Trik：如果遮挡物离当前点比较远，就不产生影响。</p>
<ul>
<li>Trace rays directly in 2D and approximate AO from horizon angle</li>
</ul>
<p><img src="AmbientOcclusion/../assets/07-8.png" alt="" /></p>
<blockquote>
<p>实际算法中有很多细节。</p>
</blockquote>
<h2 id="gtao---ground-truth-based-ambient-occlusion"><a class="header" href="#gtao---ground-truth-based-ambient-occlusion">GTAO - Ground Truth-based Ambient Occlusion</a></h2>
<h3 id="贡献1"><a class="header" href="#贡献1">贡献1</a></h3>
<blockquote>
<p>HBAO 没有考虑到角度的因素。因为从不同角度射下来的光，对点的影响是不一样的。</p>
</blockquote>
<p>GTAO introduces the missing cosine factor, removes the attenuation function, and add a fast approximation of multi bounce</p>
<p><img src="AmbientOcclusion/../assets/07-9-1.png" alt="" /></p>
<p><img src="AmbientOcclusion/../assets/07-9-2.png" alt="" /></p>
<h3 id="贡献2"><a class="header" href="#贡献2">贡献2</a></h3>
<p>Add <strong>multiple bounces</strong> by fitting a cubic polynomial per albedo</p>
<p><img src="AmbientOcclusion/../assets/07-10-2.png" alt="" /></p>
<p><img src="AmbientOcclusion/../assets/07-10-3.png" alt="" /></p>
<blockquote>
<p>用真实数据拟合了 Single Bounce AO 与 Multi Bounce AO 的关系(假设为三阶多项式)</p>
</blockquote>
<p><img src="AmbientOcclusion/../assets/07-10-1.png" alt="" /></p>
<h3 id="result-2"><a class="header" href="#result-2">Result</a></h3>
<p><img src="AmbientOcclusion/../assets/07-9-3.png" alt="" /></p>
<h2 id="ray-tracing-ambient-occlusion"><a class="header" href="#ray-tracing-ambient-occlusion">Ray-Tracing Ambient Occlusion</a></h2>
<ul>
<li>Casting rays from each screen pixel using RTT hardware
<ul>
<li>1 spp(sample per-pixel) works well for far-field occlusion</li>
<li>With 2-4 spp, can recover detailed occlusion in contact region</li>
</ul>
</li>
</ul>
<blockquote>
<p>(1) 利用 GPU 的 ray casting 能力<br />
(2) 每帧只 sample 一个方向，在时序上持续收集遮挡信息。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="高级光线传播"><a class="header" href="#高级光线传播">高级光线传播</a></h1>
<h2 id="无偏-unbiased-vs-有偏-biased"><a class="header" href="#无偏-unbiased-vs-有偏-biased">无偏 unbiased Vs 有偏 biased</a></h2>
<p>Path tracing 中使用 Monte Carlo 计算积分项的估计值。
不管采样多少样本，都满足E（估计值） = 真实值，称为无偏估计，否则为有偏估计。少量样本时有偏而极限情况下无偏，则称为consistence，这是有偏估计的一种特殊情况。</p>
<h2 id="双向路经追踪-bdpt"><a class="header" href="#双向路经追踪-bdpt">双向路经追踪 BDPT</a></h2>
<p>Baseline方法：从眼睛发出一条光路，追踪这个光路直到光源。<br />
BDPR方法：<br />
<img src="AdvancedRendering/../assets/155.PNG" alt="" /></p>
<ol>
<li>从眼睛（即摄像机）打出一条半路经</li>
<li>从光源打出一条半路经</li>
<li>把两条路往连起来，形成一条完整的路径。</li>
</ol>
<p>缺点：<br />
实现非效复杂、速度非常慢</p>
<p>效果：<br />
<img src="AdvancedRendering/../assets/156.PNG" alt="" /><br />
由于光源向上，场景大部分光来自间接光。因此大多数情况下 path tracing 的第1个 bounce 是 diffuse，导致不好控制它打到能量集中的区域去。</p>
<blockquote>
<p>💡 分析常规方法的局限场景，针对局限场景做优化。</p>
</blockquote>
<h2 id="metropolis人名-light-transport-mlt"><a class="header" href="#metropolis人名-light-transport-mlt">Metropolis(人名) Light Transport (MLT)</a></h2>
<h3 id="原理-9"><a class="header" href="#原理-9">原理：</a></h3>
<p>用&quot;马尔可夫链&quot;采样。<br />
Monto Carlo 性质：当f(x)与 p(x) 形状一致时， bias 最小，
马尔可夫链性质：可以使得采样样本符合特定的 p(x)<br />
结合两者的特点，可使得定积分的估计值与真实值的bias最小。</p>
<h3 id="方法-1"><a class="header" href="#方法-1">方法：</a></h3>
<p>当找到一个合适的path，会在这个path周围生成新的样本，这个新的样本大概率也是一个合适的path。</p>
<p><img src="AdvancedRendering/../assets/157.PNG" alt="" /></p>
<h3 id="效果-8"><a class="header" href="#效果-8">效果：</a></h3>
<p><img src="AdvancedRendering/../assets/158.PNG" alt="" /></p>
<p>适用于复杂困难的光路传播。因为只要找到一条，就能比较容易地找到更多。</p>
<h3 id="缺点"><a class="header" href="#缺点">缺点:</a></h3>
<p>难以估计算法的收敛速度。<br />
每个像素的收敛情况都不一样，多帧画面效果为抖动。</p>
<h2 id="photon-mapping光子映射"><a class="header" href="#photon-mapping光子映射">Photon Mapping光子映射</a></h2>
<p>适用于渲染 caustics.<br />
是有偏算法<br />
caustics： 由于光线聚集形成非常强的图案。适于用 specular-diffuse-specular­</p>
<h3 id="具体方法-2"><a class="header" href="#具体方法-2">具体方法</a></h3>
<ul>
<li>Stage 1</li>
</ul>
<p>光源向外辐射光子，光子 bounce 直到遇到diffuse表面，计算光子最后停留的位置</p>
<p><img src="AdvancedRendering/../assets/159.PNG" alt="" /></p>
<ul>
<li>Stage 2</li>
</ul>
<p>从 camera 出发，打出 sub path, bounce,直到遇­到 diffuse 表面。计算sub path最后停留的位置。</p>
<ul>
<li>Stage 3,</li>
</ul>
<p>计算 local density estimation，光子越集中的地方应该越亮<br />
对于任意一个着色点，取最近N个光子，计算 N 个光子所占的面积 A，可算出光子密度为­N/A。</p>
<h3 id="特点-2"><a class="header" href="#特点-2">特点</a></h3>
<p>N 太小会有噪声，N太大会糊<br />
由于光子密度是通过 N/A 估计出来的，不是真实的密度，因此该算法是有偏算法<br />
当 Stage 1中的光子数趋于\(\inf\)时， Stage 3的A趋于0，密度估计趋于正确值。因此该算法是bias but consistent 算法。<br />
如果通过固定A数光子数量来计算密度，那么光子数再多也是有偏算法。</p>
<blockquote>
<p>💡 共同目的都是找到最能体现光线传播特点的路径。</p>
</blockquote>
<h2 id="vcm-vertex-connection-and-merging-双向路经追踪--光子映射"><a class="header" href="#vcm-vertex-connection-and-merging-双向路经追踪--光子映射">VCM: Vertex Connection and Merging 双向路经追踪 + 光子映射</a></h2>
<p>原理：</p>
<p><img src="AdvancedRendering/../assets/160.PNG" alt="" /></p>
<ol>
<li>将光子停留位置（红）与 ray 停留位置（绿）连成一条 ray path.</li>
<li>如果红点和绿点非常接近，就把它们合并</li>
</ol>
<blockquote>
<p>❓ [?] 怎么理解合并这个概念。</p>
</blockquote>
<h2 id="ir-instant-radiosity"><a class="header" href="#ir-instant-radiosity">IR: Instant Radiosity</a></h2>
<h3 id="原理-10"><a class="header" href="#原理-10">原理：</a></h3>
<p>已被照亮的这些地方，也被认为是光源，并用这些光源再照亮其它地方。最终相当于光线弹射了多次。</p>
<h3 id="具体做法"><a class="header" href="#具体做法">具体做法：</a></h3>
<p><img src="AdvancedRendering/../assets/161.PNG" alt="" /></p>
<ol>
<li>从光源打出很多sub Path，最终停在某些地方</li>
<li>停住的地方会成为新的光源</li>
<li>从当 camera 看某个着色点时，用新的光源照这­个着色点</li>
</ol>
<h3 id="特点-3"><a class="header" href="#特点-3">特点</a></h3>
<p>优点：速度快<br />
缺点：</p>
<ol>
<li>有一些地方莫名其妙地发光<br />
<img src="AdvancedRendering/../assets/162.PNG" alt="" /></li>
<li>不能处理 glossy 物体</li>
</ol>
<blockquote>
<p>💡 这是与光追不同的另一套简化的建模思想，因为是简化模拟的方法，所以有Artifacts.</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="高级-appreance-建模"><a class="header" href="#高级-appreance-建模">高级 Appreance 建模</a></h1>
<h2 id="非表面模型"><a class="header" href="#非表面模型">非表面模型</a></h2>
<h3 id="反射介质"><a class="header" href="#反射介质">反射介质</a></h3>
<p>例如：雾、云</p>
<p>特点：
光线打到一个介质颗粒上，会被分散（散射）至到各个方向上（图3），也会接受到来自其它方向散射而来的光（图4）
<img src="AdvancedRendering/../assets/163.PNG" alt="" /></p>
<p>怎么散射：<br />
光线打到介质上后，散射的分布由Phase Function决定。以下是几种不同的Phase Function的例子：<br />
<img src="AdvancedRendering/../assets/164.PNG" alt="" /><br />
光线在介质中走多远由介质对光线吸收呈度决定。</p>
<p>怎么生成 path?</p>
<ol>
<li>根据 phase function 决定 bounce 方向</li>
<li>根据 吸收率决定 distance</li>
<li>形成 ray path</li>
</ol>
<h3 id="hair-表面"><a class="header" href="#hair-表面">Hair 表面</a></h3>
<p>无色高光，有色高光</p>
<h4 id="kajiya-kay-模型"><a class="header" href="#kajiya-kay-模型">kajiya-Kay 模型</a></h4>
<p>把每一根头发看成是圆柱，会把光线产生圆雉形的反射和各个方向的散射
效果：</p>
<p><img src="AdvancedRendering/../assets/165.PNG" alt="" /></p>
<h4 id="marahner-模型"><a class="header" href="#marahner-模型">Marahner 模型</a></h4>
<p>除了考虑反射、散射，还考虑折射。</p>
<p>光线与头发的作用可以有这几种：<br />
<img src="AdvancedRendering/../assets/166.PNG" alt="" /></p>
<ol>
<li>反射，圆锥形方向。 R</li>
<li>进入（折射） + 出去（折射），圆雉， T T</li>
<li>进入（折射） + 内壁（反射） + 出去（折射）， TRT</li>
</ol>
<p>对每一根头发都考虑以上的过程
效果：</p>
<h3 id="fur-表面"><a class="header" href="#fur-表面">Fur 表面</a></h3>
<p>Hair 模型缺少 Medulla 的模拟，因此用在动物上效果不好。</p>
<h4 id="double-cylinder-模型"><a class="header" href="#double-cylinder-模型">Double Cylinder 模型</a></h4>
<p>增加 TTs 和 TRTs</p>
<p><img src="AdvancedRendering/../assets/167.PNG" alt="" /></p>
<blockquote>
<p>💡 要进行高精度的模拟，细节的仿真也必不可少，关键是你怎么知道缺失的细节是什么？</p>
</blockquote>
<h3 id="granular-颗粒材质"><a class="header" href="#granular-颗粒材质">Granular 颗粒材质</a></h3>
<p>颗粒物质的建模，非常耗时</p>
<h2 id="表面模型"><a class="header" href="#表面模型">表面模型</a></h2>
<h3 id="半透明材质"><a class="header" href="#半透明材质">半透明材质</a></h3>
<p>例如：玉、水母</p>
<p>物理特点：光线从一个地方进去，从内部经过散射，然后从另一个地方出来 
<img src="AdvancedRendering/../assets/168.PNG" alt="" /></p>
<p>次表面反射BSSRDF，是BRDF的延伸：</p>
<table><thead><tr><th>BRDF</th><th>BSSRDF</th></tr></thead><tbody>
<tr><td>入射点=出射点</td><td>入射点 \(\ne\) 出射点 (BSSRDF)</td></tr>
<tr><td>各个方向积分</td><td>各个方向积分各个入射点积分</td></tr>
</tbody></table>
<p>$$
L(x_o, \omega_o) = \int_A \int_{H^2}S(x_i, \omega_i, x_o, \omega_o) L_i(x_i, \omega_i) \cos\theta_i d\omega_i dA
$$</p>
<p><img src="AdvancedRendering/../assets/169.PNG" alt="" /> </p>
<h4 id="dipole-近似"><a class="header" href="#dipole-近似">Dipole 近似</a></h4>
<p>用两个光源照射表面，能得到类似次表面映射的结果。 </p>
<p><img src="AdvancedRendering/../assets/170.PNG" alt="" /> </p>
<h3 id="布料-cloth"><a class="header" href="#布料-cloth">布料 Cloth</a></h3>
<p>布料结构 
纤维(fiber) → 股(ply) → 线(yarn) → 布(cloth)</p>
<h4 id="rendering-as-surface"><a class="header" href="#rendering-as-surface">Rendering as Surface</a></h4>
<p>根据编织的形状计算<br />
适用场景：布料表面是平面<br />
不适用场景：布料表面不是平面</p>
<h4 id="render-as-participating-media"><a class="header" href="#render-as-participating-media">Render as Participating Media</a></h4>
<p>把 cloth 看作是空间体积，划分为细小的格子.<br />
用渲染云的方式来渲染cloth。</p>
<h4 id="render-as-fiber"><a class="header" href="#render-as-fiber">Render as Fiber</a></h4>
<p>暴力计算</p>
<h3 id="细节模型"><a class="header" href="#细节模型">细节模型</a></h3>
<p>渲染效果过于完美因此不真实。因为实际上不可能这么完美，多少会有些微小的划痕。</p>
<h1 id="程序化生成外观"><a class="header" href="#程序化生成外观">程序化生成外观</a></h1>
<p>定义函数f(x, y, z)，用于查询空间中某一点的纹理</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3d纹理应用"><a class="header" href="#3d纹理应用">3D纹理应用</a></h1>
<p>纹理不只有表面，内部也可以有值。给空间任意一点都定义一个值，就是3D纹理。</p>
<h2 id="用于生成随机的3d物体表面"><a class="header" href="#用于生成随机的3d物体表面">用于生成随机的3D物体表面</a></h2>
<img src="Texture/../assets/displacement2.jpg" width = 600 />
<p>纹理并非实际定义，而是通过noise函数生成（[35:01]右）。</p>
<blockquote>
<p>💡 提前准备好的方式有很多，不一定非要把每个需要的值算出来的，关键是运行时能不能很快的获取到某个值。</p>
</blockquote>
<h2 id="用于体渲染"><a class="header" href="#用于体渲染">用于体渲染</a></h2>
<p>存储3D信息并用于渲染</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>📌 本节课大部分跟器件相关的部分都会被跳过，主要关注概念。</p>
</blockquote>
<h1 id="视场-fov"><a class="header" href="#视场-fov">视场 FOV</a></h1>
<p>FOV = Field of View，指能看到的范围</p>
<p><img src="Color/../assets/171.PNG" alt="" /></p>
<p>$$
FOV = 2(\frac{h}{2f})
$$</p>
<p>以竖直的FOV为例，h为传感器的高度，f为焦距。</p>
<p>通常以35mm大小的传感器为标准来定义相机的的FOV。</p>
<p><img src="Color/../assets/172.PNG" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="光场-light-field--lumigraph"><a class="header" href="#光场-light-field--lumigraph">光场 Light Field / lumigraph­</a></h1>
<h2 id="定义-3"><a class="header" href="#定义-3">定义</a></h2>
<p><img src="Color/../assets/173.PNG" alt="" /><img src="Color/../assets/174.PNG" alt="" /><img src="Color/../assets/175.PNG" alt="" /></p>
<p>把人能看到的东西记录下来，然后放在眼前代替真实世界，可以得到一样的视觉效果。这个提前记录下来的东西，就是简易版的光场。</p>
<h2 id="全光函数"><a class="header" href="#全光函数">全光函数</a></h2>
<p>Plenptic Function（全光函数）：
用于描述前面提到的“提前记录好的人能看到的东西” ，the set of all things that we can ever see.</p>
<p>函数定义：</p>
<p>$$
P(\theta, \phi, \lambda, t, V_x, V_y, V_z)
$$</p>
<p>说明：<br />
\(\theta, \phi\)：朝某个方向看<br />
\(\lambda\)：颜色<br />
t：时间<br />
\(V_x, V_y, V_z\)：在某个位置器<br />
返回值：在任意一个位置，任意的时刻，朝任一个方向，所接收到的任意波长的光的强度。 </p>
<h2 id="光场"><a class="header" href="#光场">光场</a></h2>
<p>光场是从全光函数的一个子集。即在任意一个位置，朝任一个方向，去（光线可逆）的光的强度。</p>
<p><img src="Color/../assets/176.PNG" alt="" /></p>
<blockquote>
<p>❗ 光场参数中的位置和方向都是2D的。<br />
✅ 物体表面的任意一个位置，可以用纹理坐标(u, v)表示。3D空间中的方向可以用\(\theta, \phi\)表示，因此都是2D的。</p>
</blockquote>
<p>因此得到了这样的结果：</p>
<p><img src="Color/../assets/177.PNG" alt="" /></p>
<p>通过光场可以得到物体从任意位置的观测。</p>
<h2 id="记录光场"><a class="header" href="#记录光场">记录光场</a></h2>
<p>实际上可以不关心到底是什么物体，只需要物体的光场。 </p>
<p><img src="Color/../assets/178.PNG" alt="" /></p>
<p>但在记录的时候，描述每一根光线的方式有点不同。这里面使用2D position和2D position来描述“任意一个位置，朝任一个方向”。</p>
<p><img src="Color/../assets/179.PNG" alt="" /></p>
<blockquote>
<p>❓ 前面提到用“2D位置+2D方向”，这里提到用“2D位置和2D位置”，其实是同一个目的，都是用于描述光场中的一根光线，为什么会需要两个不同的参数化方式呢？</p>
</blockquote>
<h3 id="光场参数化"><a class="header" href="#光场参数化">光场参数化</a></h3>
<p>方式一：</p>
<p><img src="Color/../assets/20.PNG" alt="" /></p>
<p>参数为2D position和2D direction</p>
<p>方式二： </p>
<p><img src="Color/../assets/21.PNG" alt="" /></p>
<p>参数为2D position (u, v)和2D position (s, t)</p>
<h3 id="参数化效果"><a class="header" href="#参数化效果">参数化效果</a></h3>
<p><img src="Color/../assets/22.PNG" alt="" /></p>
<p>图(a)：从同一个位置，看向目标的不同位置，得到的是原图<br />
图(b)：站在不同位置，看向目标的同一位置。</p>
<h1 id="flys-eye-光线"><a class="header" href="#flys-eye-光线">Fly's Eye 光线</a></h1>
<p>苍蝇眼睛的呈像原理就是光场。 </p>
<p><img src="Color/../assets/180.PNG" alt="" /></p>
<blockquote>
<p>👆 左图三个颜色代表来自三个方向的光，不是代表光的三元色成分</p>
</blockquote>
<p>通过 f 将像素接收到的 irradiane 分­解成 radiance 分别存储</p>
<blockquote>
<p>💡 万物皆可prepare，关键是方便的测量方式与合适的存储结构。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="physical-basis-of-color"><a class="header" href="#physical-basis-of-color">Physical Basis of Color</a></h1>
<p>白光分解原理：不同颜色的光有不同的波长和折射率</p>
<h2 id="原理-11"><a class="header" href="#原理-11">原理</a></h2>
<p>谱功率密度 = Spectral Power Distribution = SPD，用于描述混合光中不同波长的光的分布 
SPD 的特点： 线性，可相加</p>
<blockquote>
<p>📌 不关心眼睛的是呈像原理，跳过，结论是： </p>
</blockquote>
<p>$$
y = \int r(\lambda)s(\lambda)d\lambda
$$</p>
<p>说明：<br />
y:人看到的某光线的结果<br />
r:人眼对不同波长光线的感受<br />
s:某种光线的SPD</p>
<h2 id="应用"><a class="header" href="#应用">应用</a></h2>
<p>根据公式可知，不同的\(s(\lambda)\)（可得到相同的 y（同色异谱）<br />
color matching：人为调和出\(s(\lambda)\)，使得到的效果与 real world 相同.</p>
<blockquote>
<p>❓ [?] 为什么不直接用 real world 的\(s(\lambda)\)？<br />
❓ 不同的人都不同的r，怎么针对不同的r调出同样效果的s？</p>
</blockquote>
<h1 id="additive-color-加色系统"><a class="header" href="#additive-color-加色系统">Additive Color 加色系统</a></h1>
<p>$$
R = \int  s(\lambda)r(\lambda)d\lambda
$$</p>
<p>说明：<br />
s:SPD<br />
r: 某个频谱的RGB primary<br />
d：某种光线的所有频谱</p>
<p><strong>基于人眼的 color matching 和基于加色系统的 color matching，公式相似，但原理不同</strong></p>
<h1 id="颜色空间"><a class="header" href="#颜色空间">颜色空间</a></h1>
<h2 id="cie-xyz"><a class="header" href="#cie-xyz">CIE XYZ</a></h2>
<p>一套人造的 color system，色域为颜色空间中所有可表示的颜色</p>
<h2 id="srgb"><a class="header" href="#srgb">sRGB</a></h2>
<p><img src="Color/../assets/182.PNG" alt="" /></p>
<blockquote>
<p>💡这部分内容对我不太重要。有一项内容值得借鉴。
如何在二维空间中可视化三维信息。</p>
<ol>
<li>归一化<br />
任何可视化都是要先归一化的。在一个标准的尺度如分析才有意义</li>
<li>固定一个维度。<br />
选择固定哪个维度是有策略的。可以选择影响最小的维度或最便于观察的维度。也可以画多张图，每次分别固定一个维度。</li>
</ol>
</blockquote>
<h2 id="hsv"><a class="header" href="#hsv">HSV</a></h2>
<p><img src="Color/../assets/181.PNG" alt="" /></p>
<h2 id="cielab"><a class="header" href="#cielab">CIELAB</a></h2>
<p><img src="Color/../assets/183.PNG" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>📌 Film：24fps，video： 30 fps, VR: 90fps，否则会晕<br />
📌 前面动画基础部分和关键帧部分跳过了。直接进入物理仿真<br />
物理仿真：Physical Simulation 
通过推导或实现物理公式，来计算出物体的形状和位置的变化。</p>
</blockquote>
<h1 id="质点弹簧系统-mass-spring-system"><a class="header" href="#质点弹簧系统-mass-spring-system">质点弹簧系统 Mass Spring System</a></h1>
<p>Mass：质点， Sping：弹簧</p>
<p>MSS可以用于模拟绳子、头发、布料。</p>
<h2 id="a-simple-spring"><a class="header" href="#a-simple-spring">A simple Spring</a></h2>
<p><img src="Animation/../assets/23.PNG" alt="" /></p>
<p>$$
f_{a\rightarrow b} = k_s(b - a)
$$</p>
<p>\(f_{a\rightarrow b}\)代表弹簧应用在a上，使得a受到的往 b 方向去的力。<br />
假设rest length = 0，a和b之间只要有距离就会有力。<br />
\(k_s\)为弹簧系数。</p>
<p>胡克定律： </p>
<p>$$
f_{b\rightarrow a} =  - f_{a\rightarrow b}
$$</p>
<h2 id="non-zero-length-spring"><a class="header" href="#non-zero-length-spring">Non-zero Length Spring</a></h2>
<p>$$
f_{a\rightarrow b} =  k_s \frac{b-a}{||b-a||}(||b-a||-l)
$$</p>
<p>说明：<br />
\(\frac{b-a}{||b-a||}\)：归一化之后的受力方向。<br />
\(||b-a||-l\)：弹簧受力的大小，与长度有关。<br />
\(l\)：rest length，弹簧长度为\(l\)时不受力，与方向无关</p>
<p>公式中没有提到摩擦力。没有摩擦力的弹簧会永远震荡下去。</p>
<h2 id="有摩擦力的弹簧"><a class="header" href="#有摩擦力的弹簧">有摩擦力的弹簧</a></h2>
<blockquote>
<p>✅ 符号：<br />
\(x\)：位置<br />
\(\dot x\)：速度<br />
\(\ddot x\)：加速度</p>
</blockquote>
<h3 id="简单的摩擦力定义"><a class="header" href="#简单的摩擦力定义">简单的摩擦力定义</a></h3>
<p>摩擦力的大小与方向都与弹簧的速度相反。</p>
<p>$$
f_b = -k_d \dot b
$$</p>
<blockquote>
<p>💡 摩擦力是由于物理微表面的不平整引起的，但这样很难模拟。是否可以参考微表面模型的统计方法来建模？</p>
</blockquote>
<p>这种方式只能描述来自外部的摩擦力，不能描述来自弹簧内部的损耗。</p>
<h3 id="更合理的摩擦力定义"><a class="header" href="#更合理的摩擦力定义">更合理的摩擦力定义</a></h3>
<p>$$
f_b = -k_d (\frac{b-a}{||b-a||}\cdot(\dot b - \dot a)) \frac{b-a}{||b-a||}
$$</p>
<p>说明：<br />
\(fb\)：摩擦力。可将弹簧恢复到正常长度。<br />
第一项\(k_d\)：弹性系数<br />
第二项\(\frac{b-a}{||b-a||}\cdot(\dot b - \dot a)\)：在弹簧力的方向上的速度分量的大小。与a和b的相对速度有关。在特定方向上的相对速度的大小，向量点乘，得到的是一个标量。<br />
第三项\(\frac{b-a}{||b-a||}\)：力的方向与b和a的相对位置，并做了归一化。</p>
<blockquote>
<p>❓ 为什么是b相对a的速度而不是相对运动表面的速度？</p>
</blockquote>
<p>摩擦力与弹簧本身长度没有关系。</p>
<h2 id="多个弹簧的组合"><a class="header" href="#多个弹簧的组合">多个弹簧的组合</a></h2>
<p><img src="Animation/../assets/184.PNG" alt="" /></p>
<h3 id="sheets-用于布料"><a class="header" href="#sheets-用于布料">Sheets 用于布料</a></h3>
<p>增加用于抵抗切变的力：</p>
<p><img src="Animation/../assets/24.PNG" alt="" /></p>
<p>局限性：各项异性，且不能对抗弯折</p>
<p>增加用于对抗弯折的力：</p>
<p><img src="Animation/../assets/25.PNG" alt="" /></p>
<blockquote>
<p>💡 我的想法：可以增加质点对抗旋转的力</p>
</blockquote>
<h1 id="有限元方法-finite-element-method"><a class="header" href="#有限元方法-finite-element-method">有限元方法 Finite Element Method</a></h1>
<p>用于模拟汽车碰撞，考虑碰撞体内力的传导。</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="粒子系统-particle-system"><a class="header" href="#粒子系统-particle-system">粒子系统 Particle System</a></h1>
<p>基于粒子系统的动画的主要过程：</p>
<ul>
<li>创建粒子</li>
<li>（难点）计算每个粒子受到的力</li>
<li>（难点）更新粒子的位置和速度</li>
<li>移除不需要的粒子</li>
<li>渲染粒子</li>
</ul>
<p>粒子建模要考虑的力有：</p>
<ul>
<li>动力：重力、吸引力、电磁力、斥力</li>
<li>阻力：摩擦力、粘滞力</li>
<li>碰撞</li>
</ul>
<blockquote>
<p>✅ 模拟和渲染是两个独立的步骤 </p>
</blockquote>
<p>粒子系统的更多应用场景：水、星系、鸟群、分子结构</p>
<blockquote>
<p>📌 具体内容在Lecture 22</p>
</blockquote>
<h1 id="单个粒子系统"><a class="header" href="#单个粒子系统">单个粒子系统</a></h1>
<h2 id="要解决的问题"><a class="header" href="#要解决的问题">要解决的问题</a></h2>
<ul>
<li>场景一：</li>
</ul>
<p>已知：初始的 position x0，任意时刻的速度<br />
求：某个时间刻的 position</p>
<ul>
<li>场景二：</li>
</ul>
<p>已知：初始的 position X0，速度场，即在任意 position 上的速度<br />
求：某时刻的 position</p>
<p><img src="Animation/../assets/191.PNG" alt="" /></p>
<h2 id="常微分方程"><a class="header" href="#常微分方程">常微分方程</a></h2>
<p>ODE = Ordinary Differential Equation</p>
<p>$$
\frac{dx}{dt} = \dot x =  v(x, t)
$$</p>
<p>已知\(\dot x\)，求x</p>
<p>一阶常微分方程的特点：</p>
<ul>
<li>只涉及一阶微分</li>
<li>不存在对其它变量的微分</li>
</ul>
<h1 id="欧拉方法"><a class="header" href="#欧拉方法">欧拉方法</a></h1>
<h2 id="显式欧拉方法"><a class="header" href="#显式欧拉方法">显式欧拉方法</a></h2>
<p>根据上一时刻的位置、速度、加速度，根据定义求这一时刻的位置、速度、加速度。</p>
<p>$$
x^{t+\Delta t} = x^t + \Delta t \dot x^t \\<br />
\dot x^{t+\Delta t} = \dot x^t + \Delta t \ddot x^t
$$</p>
<blockquote>
<p>❗ =右边的都是上一时刻的量。=左边的都是当前时刻的量。</p>
</blockquote>
<blockquote>
<p>💡 连续问题离散化，这种思想在课程中大量运用</p>
</blockquote>
<blockquote>
<p>❓ 问：为什么有第二个公式？如果是问题一，\(\dot x^t\)已知。如果是问题二，\(\dot x^t\)跟\(x^t\)有关，应该用不到\(\ddot x^t\)。而且\(\ddot x^t\)未知，用到了也没法算<br />
答：因为问题描述那里说的不准确。已知的是点在某个时刻/位置上受到的力。力-&gt;加速度-&gt;速度-&gt;位置。</p>
</blockquote>
<p>特点：</p>
<ul>
<li>简单，直观迭代。</li>
<li>误差：用不同大小的步长\(\Delta t\)会得到不同的结果。步长越小越精确。<br />
<img src="Animation/../assets/192.PNG" alt="" /></li>
<li>不稳定，且不稳定性与步长无关<br />
<img src="Animation/../assets/193.PNG" alt="" /></li>
</ul>
<blockquote>
<p>👆 不管取多大的步长，最后一定会离开这个螺旋形的速度场。</p>
</blockquote>
<blockquote>
<p>✅ 误差不是严重的问题，因为可以通过减小步长来降低误差。但不稳定性是严重的问题，因为不管取什么步长，最后结果一定会离真实情况越来越远。<br />
✅ 误差是一阶，步长再小也是一阶。<br />
❓ 为什么有些情况下一定会不稳定，不稳定的本质原因是什么？ </p>
</blockquote>
<p>用<strong>数值方法</strong>解微分方程的共性问题：</p>
<ol>
<li>误差 VS 精度</li>
<li>不稳定， <strong>divergence</strong></li>
</ol>
<blockquote>
<p>❓ 所以不稳定的来源是数值方法而不是微分方程？</p>
</blockquote>
<blockquote>
<p>💡 我的思考：<br />
有点像花书里的&quot;病态问题'。输入的微小改变导到输出的巨大变化。<br />
也可以理解为函数在不同方向上的敏感度差别很大.</p>
</blockquote>
<p><strong>后面介绍的这些方法都是在对抗前面提到的不稳定性。</strong></p>
<h2 id="中点法-midpoint-method"><a class="header" href="#中点法-midpoint-method">中点法 Midpoint Method</a></h2>
<p><img src="Animation/../assets/194.PNG" alt="" /></p>
<ol>
<li>当前点为\(x(t)\)，用欧拉方法计算下一个时间步的位置，称为a点</li>
</ol>
<p>$$
x_a = x(t+\Delta t) = x(t) + \Delta t\cdot \dot x(t)
$$</p>
<ol start="2">
<li>取\(x(t)\)与a的中点，称为b点或mid点</li>
</ol>
<p>$$
x_{mid} = \frac{x(t) + x(t+\Delta t)}{2} \\
= x(t) + \frac{\Delta t}{2}\cdot \dot x(t)
$$</p>
<ol start="3">
<li>取mid点位置的速度作为x(t)点的速度</li>
</ol>
<p>$$
\dot x'(t) = \dot x_{mid}(t)
$$</p>
<ol start="4">
<li>用\(\dot x'(t)\)再算一次欧拉，得到c点</li>
</ol>
<p>$$
x_c = x(t+\Delta t) = x(t) + \Delta t\cdot \dot x'(t)
$$</p>
<p>直观上看，很奇怪中点法更准确。展开后发现，中点法比原方法多了二次项函</p>
<p>$$
x(t+\Delta t) = x(t) + \Delta t\cdot \dot x(t) + \frac{(\Delta t)^2}{2}\ddot x(t)
$$</p>
<h2 id="adaptive-step-size-自适应步长"><a class="header" href="#adaptive-step-size-自适应步长">Adaptive Step Size 自适应步长</a></h2>
<ol>
<li>定义初始的\(\Delta t\)为\(\Delta_0\)</li>
<li>用欧拉方法计算\(x^{t+\Delta_0}\)。即用\(\Delta_0\)算一遍欧拉方法</li>
</ol>
<p>$$
X_T = x(t) + \Delta_0\cdot \dot x(t)
$$
3. 用欧拉方计算\(x^{t+2*\frac{1}{2}\Delta_0}\)。 即用\(2*\frac{1}{2}\Delta_0\)算两遍欧拉方法</p>
<p>$$
X_{mid} = x(t) + \frac{\Delta_0}{2} \cdot \dot x(t) \\
X_{T/2} = x_{mid} + \frac{\Delta_0}{2} \cdot \dot x_{mid}
$$</p>
<p><img src="Animation/../assets/195.PNG" alt="" /></p>
<ol start="4">
<li>比较\(X_T\)和\(X_{T/2}\)，如果两者差别比较大，取后者，且将\(delta_0\)更新为\(\frac{1}{2}delta_0\)。</li>
</ol>
<h2 id="implicit-隐式的-euler-method"><a class="header" href="#implicit-隐式的-euler-method">Implicit （隐式的） Euler Method</a></h2>
<p>原问题：已知\(x^t\)和\(\dot x^t\)，求 \(x^{t+\Delta t}\)和\(dot x^{t+\Delta t}\)</p>
<p>$$
x^{t+\Delta t} = x^t + \Delta t \dot x^t \\<br />
\dot x^{t+\Delta t} = \dot x^t + \Delta t \ddot x^t
$$</p>
<p>转化为新问题：</p>
<p>$$
x^{t+\Delta t} = x^t + \Delta t \dot x^{t+\Delta t} \\<br />
\dot x^{t+\Delta t} = \dot x^t + \Delta t \ddot x^{t+\Delta t}
$$</p>
<p>部分已知，部分未知，变成了一个优化问题。</p>
<p>我的思考：<br />
显式和隐式，有种FK和IK的感觉。利用被依赖项计算依赖项，用数学公式。利用依赖项计算被依赖项，用优化问题近似。</p>
<p>优点：稳定。</p>
<blockquote>
<p>❓ 隐式也是一阶，为什么比显式的稳定？</p>
</blockquote>
<h1 id="衡量各种欧拉方法的稳定性"><a class="header" href="#衡量各种欧拉方法的稳定性">衡量各种欧拉方法的稳定性</a></h1>
<p>指标：</p>
<ul>
<li>局部截断误差：每一步会产生多少误差</li>
<li>全局积累误差</li>
</ul>
<p>重要的不是指标的数值，而是这些指标与\(\Delta t\)的关系。</p>
<p>例如 Implicit Euler Method方法的稳定性为1阶。因为的它的局部截断误差是\(O(h^2)\)，全局累积误差是O(h)。</p>
<p>O(h)的意思是，当步长减小到一半，那它的误差的期望也会减小到一半。<br />
\(O(h^2)\)的意思是，当步长减小到一半，那它的误差的期望也会减小到1/4。</p>
<p>阶数越高越好。</p>
<h1 id="runge-kutta-方法"><a class="header" href="#runge-kutta-方法">Runge-kutta 方法</a></h1>
<p>这是一类方法。<br />
欧拉方法用于解线性ODE（常微分方程），而此类方法能够解非线性的ODE。</p>
<blockquote>
<p>❓ 线性ODE和非线性的ODE什么区别？</p>
</blockquote>
<p>其中Rk 4方法应用最广泛. 4代表4阶</p>
<p>已知：</p>
<p>$$
\frac{dy}{dt} = f(t, y) \\
y(t_0) = y_0
$$</p>
<p>RK 4解法:</p>
<p>$$
y_{n+1} = y_n + \frac{1}{6}h(k_1 + 2k_2 + 2k_3 + k_4)     \\
t_{n+1} = t_n + h
$$</p>
<p>说明： 
这个公式里的h就是\(\Delta t\)<br />
()中的四个加法项是基于中点法的中间结果，系数是精心设计的</p>
<blockquote>
<p>🔎 数值分析课程会对这个算法有详细的解释</p>
</blockquote>
<p>如果说中点法是泰勒展开的即视感，那么这里的公式是对泰勒展开更精确的模拟</p>
<p>问：为什么说RK系列擅长非线性呢？都是以欧拉方法为基础，在哪里引入的非线性的设计？<br />
答：1阶是处理线性问题，高于1阶才能处理非线性。理解类似泰勒公式的近似截断。</p>
<h1 id="position-based--verlet-积分"><a class="header" href="#position-based--verlet-积分">Position Based / Verlet 积分</a></h1>
<p>原理：只是通过调整位置使得能够满足某些限制，简化弹簧的物理推导过程<br />
优点：快、简单<br />
缺点：不是基于真实的物理过程可能会有错误</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rigid-body-刚体模拟"><a class="header" href="#rigid-body-刚体模拟">Rigid Body （刚体）模拟</a></h1>
<p>刚体运动本身不会发生形变，可以简单看作是粒子扩充</p>
<p>但刚体会考虑更多的物理量的模拟：</p>
<table><thead><tr><th>物理量</th><th>物理量的变化</th></tr></thead><tbody>
<tr><td>X：position</td><td>\(\dot X\)：速度</td></tr>
<tr><td>\(\theta\)：旋转角度</td><td>\(\omega\)：角速度</td></tr>
<tr><td>\(\dot X\)：速度</td><td>\(\frac{F}{M}\)：加速度</td></tr>
<tr><td>\(\omega\)：角速度</td><td>\(\frac{\Gamma}{I}\)：角加速度</td></tr>
</tbody></table>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="流体-fluid-模拟"><a class="header" href="#流体-fluid-模拟">流体 Fluid 模拟</a></h1>
<p>把水看作是很多个 rigid body sphere 的水滴，通过模拟的有水滴的位置，来模拟水的运动.<br />
假设水珠不可压缩（刚体），修正目标为水珠的密度（与前面都是修正位置不同），类似前面的 position based 方法。</p>
<h1 id="质点法-vs-网格法"><a class="header" href="#质点法-vs-网格法">质点法 VS 网格法</a></h1>
<ul>
<li>质点法，又称为拉格朗日方法。依次分析每一个质点的运动。</li>
<li>网格法，又称为欧拉方法（与前面提到的欧拉方法解ODE没有关系）。把场景分成网格，分析网格随着时间的变化。</li>
<li>MPM，material point method，以上两种方法的结合。</li>
</ul>
<blockquote>
<p>✅ 这里的网格跟体素不是一回事。质点、体素都是对物理的描述，网格是对环境的描述。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="欧拉-vs-拉格朗日-lagrangian"><a class="header" href="#欧拉-vs-拉格朗日-lagrangian">欧拉 Vs. 拉格朗日 Lagrangian</a></h1>
<p>欧拉：把物体看作网格，分析网格运动 （网格法）<br />
拉格朗日：把物体看作大量粒子，分析每个质子的运动。（质点法）<br />
混合法：粒子→网格→模拟→网格→粒子（有点的BVH的感觉）</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="theme/pagetoc.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
